<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>条例10： 当重写equals方法时遵循通用契约 | think-build-share</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/vuepress/favicon.ico">
    <script language="javascript" type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/js/MouseClickEffect.js"></script>
    <meta name="description" content="Just playing around">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.4603f7b5.css" as="style"><link rel="preload" href="/assets/js/app.198c1c7f.js" as="script"><link rel="preload" href="/assets/js/3.e89c7bc2.js" as="script"><link rel="preload" href="/assets/js/1.f801d562.js" as="script"><link rel="preload" href="/assets/js/37.66334c26.js" as="script"><link rel="prefetch" href="/assets/js/10.9e9a9a99.js"><link rel="prefetch" href="/assets/js/11.3ed6a9a8.js"><link rel="prefetch" href="/assets/js/12.1bec8c85.js"><link rel="prefetch" href="/assets/js/13.265db576.js"><link rel="prefetch" href="/assets/js/14.97e09b0a.js"><link rel="prefetch" href="/assets/js/15.2ec2469c.js"><link rel="prefetch" href="/assets/js/16.788c4eb5.js"><link rel="prefetch" href="/assets/js/17.3ba649a8.js"><link rel="prefetch" href="/assets/js/18.7dd75726.js"><link rel="prefetch" href="/assets/js/19.1aebbbde.js"><link rel="prefetch" href="/assets/js/20.dd8d4020.js"><link rel="prefetch" href="/assets/js/21.e249a984.js"><link rel="prefetch" href="/assets/js/22.4d68d91d.js"><link rel="prefetch" href="/assets/js/23.4ad45b35.js"><link rel="prefetch" href="/assets/js/24.be0c09ac.js"><link rel="prefetch" href="/assets/js/25.97582c89.js"><link rel="prefetch" href="/assets/js/26.777f93a1.js"><link rel="prefetch" href="/assets/js/27.b16f6d8c.js"><link rel="prefetch" href="/assets/js/28.ea08c8e9.js"><link rel="prefetch" href="/assets/js/29.24d6fb71.js"><link rel="prefetch" href="/assets/js/30.8510435b.js"><link rel="prefetch" href="/assets/js/31.6253aec9.js"><link rel="prefetch" href="/assets/js/32.0dd560a4.js"><link rel="prefetch" href="/assets/js/33.65361602.js"><link rel="prefetch" href="/assets/js/34.f27436cb.js"><link rel="prefetch" href="/assets/js/35.7ac29299.js"><link rel="prefetch" href="/assets/js/36.1925b76e.js"><link rel="prefetch" href="/assets/js/38.ad378120.js"><link rel="prefetch" href="/assets/js/39.b8c80c17.js"><link rel="prefetch" href="/assets/js/4.6d2297c8.js"><link rel="prefetch" href="/assets/js/40.6e9acd1c.js"><link rel="prefetch" href="/assets/js/41.4c0dde9e.js"><link rel="prefetch" href="/assets/js/42.136aac0d.js"><link rel="prefetch" href="/assets/js/43.2ed33d60.js"><link rel="prefetch" href="/assets/js/44.5f0958a7.js"><link rel="prefetch" href="/assets/js/45.d8af4376.js"><link rel="prefetch" href="/assets/js/46.47414fa6.js"><link rel="prefetch" href="/assets/js/47.236a103d.js"><link rel="prefetch" href="/assets/js/48.eb854a20.js"><link rel="prefetch" href="/assets/js/49.d105ebf1.js"><link rel="prefetch" href="/assets/js/5.0bad958f.js"><link rel="prefetch" href="/assets/js/50.81578e80.js"><link rel="prefetch" href="/assets/js/51.50020fb7.js"><link rel="prefetch" href="/assets/js/52.ba1978dc.js"><link rel="prefetch" href="/assets/js/53.14cf8caf.js"><link rel="prefetch" href="/assets/js/54.50dcb08c.js"><link rel="prefetch" href="/assets/js/55.57c793c6.js"><link rel="prefetch" href="/assets/js/56.42aef2b5.js"><link rel="prefetch" href="/assets/js/57.d191e17d.js"><link rel="prefetch" href="/assets/js/58.cf46b1f1.js"><link rel="prefetch" href="/assets/js/59.2b663f38.js"><link rel="prefetch" href="/assets/js/6.fa56699c.js"><link rel="prefetch" href="/assets/js/60.e3407b1e.js"><link rel="prefetch" href="/assets/js/61.8f658a38.js"><link rel="prefetch" href="/assets/js/62.49cc39d7.js"><link rel="prefetch" href="/assets/js/63.312918bd.js"><link rel="prefetch" href="/assets/js/64.ad64e103.js"><link rel="prefetch" href="/assets/js/65.16e8c687.js"><link rel="prefetch" href="/assets/js/66.39969a99.js"><link rel="prefetch" href="/assets/js/67.c6bf4b85.js"><link rel="prefetch" href="/assets/js/68.a9569d5e.js"><link rel="prefetch" href="/assets/js/69.07dee552.js"><link rel="prefetch" href="/assets/js/7.e29bd960.js"><link rel="prefetch" href="/assets/js/70.6eb5c190.js"><link rel="prefetch" href="/assets/js/71.d9eeb169.js"><link rel="prefetch" href="/assets/js/72.4bd38647.js"><link rel="prefetch" href="/assets/js/73.4894419e.js"><link rel="prefetch" href="/assets/js/74.7ca0518b.js"><link rel="prefetch" href="/assets/js/75.992062db.js"><link rel="prefetch" href="/assets/js/76.0d4a6fb8.js"><link rel="prefetch" href="/assets/js/77.0e400fc3.js"><link rel="prefetch" href="/assets/js/78.856242bd.js"><link rel="prefetch" href="/assets/js/79.f33266da.js"><link rel="prefetch" href="/assets/js/8.530ccac1.js"><link rel="prefetch" href="/assets/js/80.c6e7e3b5.js"><link rel="prefetch" href="/assets/js/81.0076c66b.js"><link rel="prefetch" href="/assets/js/82.c3e5e4fb.js"><link rel="prefetch" href="/assets/js/83.fc52047e.js"><link rel="prefetch" href="/assets/js/84.f87af67f.js"><link rel="prefetch" href="/assets/js/85.cf37baf7.js"><link rel="prefetch" href="/assets/js/86.237cd68c.js"><link rel="prefetch" href="/assets/js/87.89e5e27f.js"><link rel="prefetch" href="/assets/js/88.fb79632a.js"><link rel="prefetch" href="/assets/js/9.827f66a6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4603f7b5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-9f1e2f90><div data-v-9f1e2f90><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-9f1e2f90 data-v-9f1e2f90><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-58d5ab76 data-v-9f1e2f90 data-v-9f1e2f90><h3 class="title" style="display:none;" data-v-58d5ab76 data-v-58d5ab76>think-build-share</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><input type="password" value="" data-v-58d5ab76> <span data-v-58d5ab76>Konck! Knock!</span> <button data-v-58d5ab76>OK</button></label> <div class="footer" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><span data-v-58d5ab76><i class="iconfont reco-theme" data-v-58d5ab76></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-58d5ab76>vuePress-theme-reco</a></span> <span data-v-58d5ab76><i class="iconfont reco-copyright" data-v-58d5ab76></i> <a data-v-58d5ab76><span data-v-58d5ab76>think-build-share</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-9f1e2f90><header class="navbar" data-v-9f1e2f90><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">think-build-share</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask" data-v-9f1e2f90></div> <aside class="sidebar" data-v-9f1e2f90><div class="personal-info-wrapper" data-v-3eba7259 data-v-9f1e2f90><!----> <h3 class="name" data-v-3eba7259>
    think-build-share
  </h3> <div class="num" data-v-3eba7259><div data-v-3eba7259><h3 data-v-3eba7259>1</h3> <h6 data-v-3eba7259>Article</h6></div> <div data-v-3eba7259><h3 data-v-3eba7259>1</h3> <h6 data-v-3eba7259>Tag</h6></div></div> <hr data-v-3eba7259></div> <!----> <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">首页</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三省吾身</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>万丈高楼平地起</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web技术</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring Boot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ORM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>字符集</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>团队与实践</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>C(++)</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>软件设计</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-58d5ab76 data-v-9f1e2f90><h3 class="title" style="display:none;" data-v-58d5ab76 data-v-58d5ab76></h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><input type="password" value="" data-v-58d5ab76> <span data-v-58d5ab76>Konck! Knock!</span> <button data-v-58d5ab76>OK</button></label> <div class="footer" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><span data-v-58d5ab76><i class="iconfont reco-theme" data-v-58d5ab76></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-58d5ab76>vuePress-theme-reco</a></span> <span data-v-58d5ab76><i class="iconfont reco-copyright" data-v-58d5ab76></i> <a data-v-58d5ab76><span data-v-58d5ab76>think-build-share</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-9f1e2f90><main class="page"><div class="page-title" style="display:none;"><h1 class="title">条例10： 当重写equals方法时遵循通用契约</h1> <div data-v-42458482><i class="iconfont reco-account" data-v-42458482><span data-v-42458482>think-build-share</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default" style="display:none;"><h2 id="条例10-当重写equals方法时遵循通用契约"><a href="#条例10-当重写equals方法时遵循通用契约" class="header-anchor">#</a> 条例10： 当重写equals方法时遵循通用契约</h2> <p>重写equals方法看起来简单，但是有许多种出错的方式，而且结果可能很可怕。最简单避免的方式是不重写equals方法，
这种情况下，类的实例只和它本身相等。如果满足以下任意条件，那么是可以这么做的：</p> <ul><li>类的每个实例本质上是唯一的。诸如Thread这样代表了活动实体而不是值的类。Object提供的equals实现正具有这样的
行为。</li> <li>类无需提供逻辑相等的验证。比如，<code>java.util.regex.Pattern</code>本可以重写equals来检查Pattern的2个实例是否
代表了相同的正则表达式，但是设计者不认为客户端代码会需要或者想要哦这个功能。在这些情况下，从Object继承来的
equals实现是理想的</li> <li>父类已经重写了equals方法，且父类的行为适合当前类。比如，大多数Set的实现从AbstractSet继承了equals实现，List的实现
从AbstractList继承了equals实现，Map的实现从AbstractMap继承了equals实现。</li> <li>类是私有的或包级私有的，且确定它的equals方法永远不会被调用。如果你极力规避风险，你可以重写equals方法确保
它不会被意外调用。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Method is never called</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么何时适合重写equals方法呢？当类的逻辑相等的概念和单纯的对象相等不一样且父类还没重写equals方法时。通常是值类的情况。
值类简单来说是表示一个值的类，如Integer或String。使用equals方法比较值对象的引用的程序员希望引用是否逻辑相等，而不是
检查它们是否指向同一个对象。重写equals方法来满足程序员的期望是必须的，同时它也能使得实例作为Map的键或Set元素以获得
可预测，希望的行为。</p> <p>一种不需要重写equals方法的值类是使用实例控制确保每个值只会存在一个对象的类。Enum类型就是这一类的。对于这些类，逻辑相等就是
对象相等。此时对象的equals方法用作逻辑相等。</p> <p>当重写了equals方法，必须遵守它的通用契约。如下是契约，来自Object的规范：
equals方法实现了等价关系，它有这些属性：</p> <ul><li>自反：对于任何非null的引用值x，<code>x.equals(x)</code>必须返回true</li> <li>对称性：对于任何非null引用值x和y，<code>x.equals(y)</code>当且仅当<code>y.equals(x)</code>返回true时返回true</li> <li>传递性：对于任何非null引用值x,y,z，如果<code>x.equals(y)</code>返回true且<code>y.equals(z)</code>返回true，那么<code>x.equals(z)</code>必须返回true</li> <li>一致性：对于任何非null引用值x和y,当equals比较用的信息没有修改时，多次调用<code>x.equals(y)</code>必须一致地返回true或一致返回false。</li> <li>对于任何非null引用值x，<code>x.equals(null)</code>必须返回false</li></ul> <p>如果你不喜欢数学，上面这些属性看起来可能有点恐怖，但不要忽视它！如果违反它，你可能发现你的程序行为遗产或崩溃，而且很难确定
失败的来源。仿照约翰多恩的话，没有哪个类是座孤岛。类的实例被频繁地传递给其他实例。许多类，包括所有的集合类，依赖于传递给它们的
对象遵守equals契约。</p> <p>现在意识到违反equals契约的危险后，让我们仔细看下这个契约。好消息是，它真没看起来那么复杂。一旦你理解它，遵守它也不难。</p> <p>那么什么是等价关系？非正式来说，它是将元素集划分成子集中元素互相相等的运算符。这些子类就是熟知的等价类。equals方法
要有用，那么从使用者的角度来看每个等价类中的所有元素必须可互换的。</p> <p>自反性——第一个要求只提到，对象必须和其自身想等。很难想象无意违反它。如果违反了它，那么添加类实例到集合中后，contains
方法会提示集合不包含刚才添加的实例。</p> <p>对称性——第二个要求说，任何两个对象都必须就它们是否相等达成一致。和第一个要求不样，无意间违反它并不难想象。比如，看下面的类，
它实现了大小写不敏感的字符串。字符串在toString中大小写敏感，但在equals方法比较中忽略了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 裂开 - 违反对称性!</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">CaseInsensitiveString</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> s<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">CaseInsensitiveString</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 裂开 - 违反对称性!</span>
  <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">CaseInsensitiveString</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">CaseInsensitiveString</span><span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token comment">// 单向互换性</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 其他代码省略</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上造出的equals方法本意尝试和普通字符串互操作。让我们假设一个大小写不敏感的字符串和一个普通串。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">CaseInsensitiveString</span> cis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CaseInsensitiveString</span><span class="token punctuation">(</span><span class="token string">&quot;Polish&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;polish&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>如预期的，<code>cis.equals(s)</code>返回true。问题在于CaseInsensitiveString中的equals方法知道普通字符串。String类的
equals方法忽略带瞎写不敏感的子串。所以<code>s.equals(cis)</code>返回false，明显违反了对称性。假设吧大小写不敏感的字符串
放入集合：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CaseInsensitiveString</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cis<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>list.contains(s)</code>这时返回什么？谁知道呢？在当前OpenJDK实现，它碰巧返回false。但这只是一种实现构件。在另一种实现中，
可以很容易返回true或者扔出运行时异常。一旦违反了equals契约，你根本不知道其他对象在遇到违反契约的对象如何反应。</p> <p>要消除这个问题，仅移除掉equals方法中那段与String互操作尝试的错误代码。之后，可以将方法重构成单条返回语句。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span> 
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> o <span class="token keyword">instanceof</span> <span class="token class-name">CaseInsensitiveString</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">CaseInsensitiveString</span><span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span>s<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>传递性——equals契约的第三个要求说如果一个对象和第二个对象相等，第二个对象和第三个对象相等，那么第一个对象必须和第三个对象
相等。同样，不难想象无意违反这个要求。假设这么个场景：子类在父类中添加一个新的值组件。换句话说，子类添加了一段影响equals
比较的信息。让我们以一个简单的不可变的二维整型点类作为开始：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Point</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span>x <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>y <span class="token operator">==</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 剩下的省略</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假设要继承这个类，将颜色的概念添加到点中：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Color</span> color<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token class-name">Color</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Remainder omitted</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么equals该怎么实现？如果省略了equals，从Point继承实现，那么equals比较中的color信息就被忽略了。尽管不违反
equals契约，但明显不能接受。假设编写了equals方法且只在参数是另外一个具有相同位置和颜色的色点时才返回true：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 裂开 - 违反了对称性!</span>
<span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ColorPoint</span><span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span>color <span class="token operator">==</span> color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法的问题在于当你在比较点和色点及反过来比较色点和点时获得的不同结果。比较点和色点将忽略颜色，
而比较色点和点则总是返回false，因为参数的类型不正确。为了具体说明，让我们创建一个点和一个色点：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ColorPoint</span> cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Color</span><span class="token punctuation">.</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>然后<code>p.equals(cp)</code>返回true，然而<code>cp.equals(p)</code>返回false。在做“混合比较”时，你可能会尝试通过让ColorPoint.equals忽略颜色
来修复这个问题：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 裂开 - 违反传递性!</span>
<span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Point</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果 o是常规Point, 忽略色彩比较</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// o 是 ColorPoint; 全属性比较</span>
  <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ColorPoint</span><span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span>color <span class="token operator">==</span> color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种方式确实提供了对称性，但是以传递性为代价：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ColorPoint</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Color</span><span class="token punctuation">.</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Point</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ColorPoint</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Color</span><span class="token punctuation">.</span>BLUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>p1.equals(p2)</code>及<code>p2.equals(p3)</code>返回true，然而<code>p1.equals(p3)</code>返回false。明显违反了传递性。前两个比较无视颜色，
然而第三个比较考虑了颜色。</p> <p>同时，这种方式可能造成无限递归：假设有Point的2个子类，比如说ColorPoint和SmellPoint。每个都具有这种equals方法。
然后调用<code>myColorPoint.equals(mySmellPoint)</code>将扔出堆栈溢出错误。</p> <p>那么解决方案是啥？事实上，这是面向对象语言中等价关系的根本问题。在保持等价契约的同时无法扩展可实例化的类并添加值组件。
除非你愿意放弃面向对象抽象的好处。</p> <p>你可能听说通过在equals方法中使用getClass验证来替代instanceOf可实现继承可实例化的类并添加值组件的类的同时保留equals契约。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 裂开 - 违反了里氏替换原则</span>
<span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> p<span class="token punctuation">.</span>x <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>y <span class="token operator">==</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样产生的对象相等的条件是只在他们有相同实现类。这似乎不那么坏，但是后果是不可接受的：Point子类的实例仍是一个
Point，它仍需要作为Point来运作，但是如果采用上面这种方式，它将不能这么运作！让我们假设写一个方法来验证一个点
是否在单个圆上。下面是我们可采用的一种方式：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 实例化 unitCircle来包含单个圆上所有的点</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Set</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">Point</span> <span class="token punctuation">&gt;</span></span> unitCircle <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
<span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">onUnitCircle</span><span class="token punctuation">(</span><span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> unitCircle<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>尽管这可能不是最快实现功能的方式，但可以正常运行。假设扩展Point类。假设以某种不添加组件的细微的方式来扩展Point，
比如，让构造函数追踪创建了多少个实例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CounterPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">CounterPoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    counter<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numberCreated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> counter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>里氏替换原则说类型的任何重要属性也应适用于其所有子类型，以便为该类型编写的所有方法均应在子类型上同样有效<code>[Liskov87]</code>
这是我们之前提到的Point子类（比如CounterPoint）仍然是Point并且作为Point运作的说法的正式表述。
但是假设我们传递CounterPoint到onUnitCircle方法。如果Point类使用基于getClass的equals方法，那么onUnitCircle
方法将返回false，无论CounterPoint实例的x和y坐标是啥。产生这种结果的原因是大多数集合，包括在onUnitCircle方法中
使用的HashSet，使用equals方法来验证是否包含元素，且没有CounterPoint实例和任何Point等价。然而，如果在Point类使用了合适的
基于instanceOf的equals方法，当提供CounterPointer实例时，相同的onUnitCircle方法将可以正常工作。</p> <p>尽管没有令人满意的方式实现扩展一个可实例化的类并添加一个组件的同时，满足equals契约，但有一个变通方式：遵循条例18，
优先使用组合而不是继承。不让ColorPoint扩展Point，给ColorPoint添加一个私有的Point字段和一个公共的view方法（条例6）
来返回和色点在相同位置的点</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 不违反equals契约的情况下添加值组件</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Point</span> point<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Color</span> color<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token class-name">Color</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
* 返回色点的点视图
*/</span>
  <span class="token keyword">public</span> <span class="token class-name">Point</span> <span class="token function">asPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> point<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span> 
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">ColorPoint</span> cp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ColorPoint</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> cp<span class="token punctuation">.</span>point<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> cp<span class="token punctuation">.</span>color<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 剩下的省略</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Java平台库中确实有些类继承了可实例化类且添加了值组件。比如<code>java.sql.Timestamp</code>继承了<code>java.util.Date</code>且添加了
nanoseconds字段。Timestamp的equals实现确实违反了对称性且在Timestamp和Date对象用在相同的集合或者混用时可能会导致
错误的行为。Timestamp类有个免责声明提醒程序员不要混用dates和timestamps。尽管只要将他们分开使用，不会陷入麻烦，
但没有什么可以阻止混用他们，导致错误很难调试。Timestamp类的行为是一个错误且不应该被模仿。</p> <p>注意你可以在继承抽象类后添加值组件而不违反equal契约。这对于通过遵守条例23获得的类层次结构是重要的。优先于标记的类使用类层次结构。
比如，你可以创建没有值组件的抽象类Shape，子类Circle添加了radius字段，子类Rectangle添加了长和宽字段。只要不可能直接创建父类的实例，
就不会出现前面提到的问题。</p> <p>一致性——equals契约的第四个要求说如果两个对象是相等的，他们必须一直相等，除非它们中的一个被修改了。换句话说，可变对象在不同
时间可以和不同对象相等，而不可变对象则不可以。当你编写一个类时，想清楚它是否应该是不可变的（条例17）。如果得出它不可变的结论，
确保equals方法强制相等对象一直保持相等，不相等对象一直保持不等的限制。</p> <p>不管类是否是可变的，不要编写依赖于不可靠资源的equals方法。如果违反了这个禁令，那么会极难满足一致性需求。比如<code>java.net.URL</code>
的equals方法依赖和URL关联的主机的IP的比较。将主机名转换为IP地址会需要网络访问，不能保证随着时间的变化会产生一致的结果。
这可能导致URL的equals方法违反equals契约且在实际中产生问题。URL的equals方法的行为是一个重大错误且不该被模仿。不幸的是，
由于兼容性的需求，它不能被变更。要避免这类问题，equals方法只该执行驻留内存的对象的确定性计算。</p> <p>非null性——最后的要求缺少一个官方名称，所以我冒昧地称其为非null。它说所有的对象都必须不等于null。尽管很难想象调用
<code>o.equals(null)</code>方法时突然返回了true。但不难想象突然扔出NullPointerException。通用契约禁止这一点。许多类的equals
方法都显示地验证null以防止它。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span> 
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个测试是没有必要的。要测试参数的等价性，equals方法必须首先将参数转换为合适的类型以便可以调用其访问器或访问它的字段。
在做转换前，方法必须使用instanceOf操作符来验证参数是正确的类型。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span> 
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">MyType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token class-name">MyType</span> mt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyType</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果缺失类型检查，若equals方法传入一个错误类型参数，equals方法会扔出ClassCastException，这违反了equals契约。
但instanceOf操作符的第一个操作数为null时会返回false，不管第二个操作数是什么类型。所以当传入null时类型检查将
返回false，所以不需要额外的null检查。</p> <p>综上，下面是书写高质量equals方法的处方：</p> <ol><li>使用==操作符检查参数是不是这个对象的引用。
如果是，返回true。这只是性能优化，但是值得这样做，防止对象的比较潜在的大开销。</li> <li>使用instanceOf操作符检查参数具有正确的类型。
如果类型不正确，返回false。通常，正确的类型是这个方法所在的类的类型。偶尔，它是这个类实现的接口的类型。
如果类实现的接口细化了equals契约允许跨实现接口的类进行比较，那么使用接口。集合接口诸如Set，List，Map和
Map.Entry都有这个这个特性。</li> <li>将参数转换为正确的类型。因为这个转换由之前的instanceOf检查做保障，它能确保成功。</li> <li>对类中每个重要的字段，检查作为参数的字段是否和对象的对应字段匹配。
如果所有这些验证通过，返回true，否则返回false。如果第二步的类型为接口，必须通过接口方法访问参数字段。
如果类型是类，也许能直接访问字段，取决于它们的访问性。</li></ol> <p>对于基本类型字段，类型不是float和double的，使用==操作符来比较；对于对象引用字段，递归调用equals方法。
对于float字段，使用静态的<code>Float.compare(float, float)</code>方法。对于double字段，使用<code>Double.compare(double,double)</code>。
由于存在Float.NaN, -0.0f和类似的double值，因此有必要对float和double字段的值作特殊处理。参看JLS15.21.1或者Float.equals
文档以了解细节。尽管可以通过<code>Float.compare(float, float)</code>和<code>Double.compare(double,double)</code>比较float和double字段，
这意味着每次比较时将自动装箱，这会导致性能不佳。对于数组字段，对每个元素应用这些处方。如果数组字段的每个元素都是重要的，
使用Arrays.equals方法中的一个。</p> <p>一些对象引用可能合法包含null。为避免NullPointerException的可能，使用<code>Object.equals(Object,Object)</code>静态方法来检查想等性。
对于一些类，如上面的CaseInsensitiveString，字段比较比简单的相等验证更加复杂。如果是这样，你可能想要存储字段的规范形式，以便
equals方法可以对规范形式进行小开销的明确比较，而不是进行更昂贵的非标准比较。这个技术最适合用在不可变类（条例17）中。如果对象
可以变更，必须保持规范形式最新。</p> <p>equals方法的性能可能会受到字段比较顺序的影响。为获得最好性能，应该首先比较最可能不同的字段，开销最少的字段，或者理想情况下，两者。
禁止比较不是对象逻辑状态部分的字段，比如用来同步操作的锁字段。不需要比较从有效字段派生出的字段，但这样可能会提升equals方法性能。
如果派生字段等于整个对象的描述，对于比较失败的情况下，比较这个字段比比较整个实际数据开销要小。比如，有个多边形类，可以
缓存面积。如果两个多边形面积不等，则不需要麻烦去比较它们的边和顶点。</p> <p>当写完了equals方法，问自己3个问题：它是对称的吗？可传递的吗？一致的吗？不仅仅问自己，还要写单元测验证，除非使用AutoValue
来生成equals方法，这种情况下可以省略测试。如果特性没有遵守，查出原因，根据实际情况修改equals方法。当然，equals方法必须
也能满足其他的2个特性（自反和非null），但这2个通常能满足。</p> <p>一个根据如上指示构造的equals方法如下面展示的简化的PhoneNumber类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//具有典型的equals方法的类</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PhoneNumber</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">short</span> areaCode<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> lineNumber<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">PhoneNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> areaCode<span class="token punctuation">,</span> <span class="token keyword">int</span> prefix<span class="token punctuation">,</span> <span class="token keyword">int</span> lineNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>areaCode <span class="token operator">=</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span>areaCode<span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">,</span> <span class="token string">&quot;area code&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>prefix <span class="token operator">=</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">,</span> <span class="token string">&quot;prefix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lineNumber <span class="token operator">=</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span>lineNumber<span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">,</span> <span class="token string">&quot;line num&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">short</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token class-name">String</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> val <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>arg <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">PhoneNumber</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">PhoneNumber</span> pn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PhoneNumber</span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>pn<span class="token punctuation">.</span>lineNumber <span class="token operator">==</span> lineNumber<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pn<span class="token punctuation">.</span>prefix <span class="token operator">==</span> prefix<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pn<span class="token punctuation">.</span>areaCode <span class="token operator">==</span> areaCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//其他代码省略...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后：如下注意下：</p> <ul><li>重写equals时总是重写hashCode（条例11）</li> <li>不要尝试过于聪明。如果仅仅标胶字段的相等性，那么不难遵守equals契约。如果你在查找相等性方面过于激进。那么很容易陷入麻烦。
考虑任意形式的别名通常是一个糟糕的主意。比如，File类不该尝试比较引用相同文件的快捷链接。谢天谢地，它并没有这样做。</li> <li>在equals方法中不要替换Object类型为其他的类型。程序员像下面这样写equals方法且花数个小时困惑为什么不能正常工作的情况并不少见。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 裂开，参数类型必须是Object</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">MyClass</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>问题在于这个方法并没有重写Object.equals方法，该方法的参数是Object类型。这个方法重载了equals方法。提供这样的
强类型的equals方法甚至是在有常规的equals方法后附加这么一个equals方法都是不能采用的，因为它可能导致子类的Override注解
产生误报且提供错误安全感。</p> <p>一直使用Override注解，正如贯穿本条例所展示的，将防止引发这种错误（条例40）。下面的equals方法不会编译，错误的信息将
提示什么出错了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 仍然裂开, 但不会编译通过。</span>
<span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">MyClass</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编写和验证equals（和hashCode）方法是枯燥的，并且产生的结果代码很普通。一个极好的替代手工编写和测试这些方法的方案是
使用Google的开源AutoValue框架，它会自动产生这些方法，通过类上的单个注解。在许多情况下，由AutoValue产生的方法和你编写
的那些方法基本相同。</p> <p>集成开发工具(IDEs)也有设施来产生equals和hashCode方法，但是和AutoValue比，结果代码更冗余，更不具可读性。
IDEs也不自动追踪类的变更，因此需要测试。通常说，通过IDEs产生equals（和hashCode）方法通常比手动实现它们
更可取，因为IDEs不会粗心出错，但我们会。</p> <p>总结下，除非必须，不要重写equals方法：在许多情况下，从Object继承来的实现正是你需要的。如果你重写了
equals，确保比较类的所有有效字段，并以保留equals契约所有5项规定的方式比较。</p></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.198c1c7f.js" defer></script><script src="/assets/js/3.e89c7bc2.js" defer></script><script src="/assets/js/1.f801d562.js" defer></script><script src="/assets/js/37.66334c26.js" defer></script>
  </body>
</html>
