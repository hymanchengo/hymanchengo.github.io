(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{565:function(n,v,_){"use strict";_.r(v);var a=_(4),t=Object(a.a)({},(function(){var n=this,v=n.$createElement,_=n._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[_("h2",{attrs:{id:"java开发预热"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java开发预热"}},[n._v("#")]),n._v(" java开发预热")]),n._v(" "),_("h3",{attrs:{id:"环境准备之标配-供参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#环境准备之标配-供参考"}},[n._v("#")]),n._v(" 环境准备之标配（供参考）")]),n._v(" "),_("p",[n._v("内存8G以上的电脑，500G以上固态\nIDEA\nidea辅助开发插件 mybatis\ngithub 账号\njdk8\ngradle可不装\nchrome浏览器")]),n._v(" "),_("p",[n._v("JAVA基础概览\n常用基本数据类型 位数记忆\nboolean byte char (16位的unicode字符)short int long  float double")]),n._v(" "),_("p",[n._v("引用类型\n基础类型对应的装箱类型Byte Char Short Integer\nLong Double Float\nString  Decimal\n数组\n类\n接口\ninterface关键字修饰，里面一组没有实现的方法。接口自JAVA8起可以有静态方法，可以有默认实现。\n枚举\n注解\n元数据的一种形式，表示不属于程序本身的数据，不影响程序代码本身的执行\n注解的使用场景\n编译期用来检测错误和缄默警告\n编译期和部署期，某些软件工具用来生成代码\n运行期某些注解也可以被检测到")]),n._v(" "),_("p",[n._v("注解并不陌生，在实现接口时，方法实现上的@override，缄默警告的@suppresswarning.都是注解，注解里可以有属性，当只有一个属性时可以省略属性名，当没有属性时注解后面的括号可以省略。")]),n._v(" "),_("p",[n._v("注解一般用在声明上面，如类的声明，方法声明，字段声明上，注解一般独占一行，且注解在JAVA8之前是不可以重复的，JAVA8后可重复注解可以用在声明上多次。另外jAVA8出现了类型注解，注解可以用在类型旁边")]),n._v(" "),_("p",[n._v("泛型\n在编译期即可检测出类型错误，增加代码的健壮性\n泛型使得类型成为定义类，接口，方法时的\n参数，使得相同的代码可以用在不同的类型输入上。")]),n._v(" "),_("p",[n._v("另外泛型消除了强制类型转换\n泛型使得可以编写通用算法 工作在不同的类型集上，类型安全且具有可读性")]),n._v(" "),_("p",[n._v("使用泛型的好处是获得强类型检查，在编译期间就可发现并修正错误，其次，")]),n._v(" "),_("p",[n._v("流程控制语句\nif else if  while for switch case\n分支语句\nbreak continue return\nbreak continue可以结合label，以跳出和继续指定循环。\n面向对象\n封装，行为和数据封装到类中\n继承，代码复用。\n多态，动态")]),n._v(" "),_("p",[n._v("包的概念，一种命名空间，可以理解为文件夹，通常将一组相关的类和接口组织到一起，这个组织单元就是包。")]),n._v(" "),_("p",[n._v("变量\n标识符\n语句\n表达式\n注释\n操作符")]),n._v(" "),_("p",[n._v("面向对象\n封装性"),_("br"),n._v("\n访问修饰符 private protected public 及包级访问")]),n._v(" "),_("p",[n._v("类的定义  构造函数 字段 方法\n默认构造函数\nthis super关键字\n对象的创建 new")]),n._v(" "),_("p",[n._v("类代码及功能复用   继承，单继承\n多态 父类或接口变量指向子类或接口实现类\n在运行期动态获得对象行为的能力")]),n._v(" "),_("p",[n._v("抽象类abstract 关键字修饰的类，不可直接new出实例，abstract修饰的方法是抽象方法，抽象类中可以有具体实现，继承抽象类的类要么全部实现抽象方法，要么本身也会成为抽象类。")]),n._v(" "),_("p",[n._v("内部类\nstatic关键字\nfinal关键字")]),n._v(" "),_("p",[n._v("第一个项目")]),n._v(" "),_("p",[n._v("JAVA语言基础\n面向对象概念\n泛型\n集合\n异常处理\nIO\nbasic io nio.2\n流的概念\n流代表来源和目标，输入流表示从源读入，输出流表示输出到目标。流的基本单位可以是字节，字符，基本数据类型还可以是对象，而来源和目标可以是任何可以存储，处理和传输流介质，如磁盘文件，数组，套接字或其他设备")]),n._v(" "),_("p",[n._v("序列化\n序列化是一种技术，什么技术？用在什么场景，为什么需要这种技术？")]),n._v(" "),_("p",[n._v("序列化是一种将对象及可触达的对象编码成字节流的技术，反序列化可以从字节流中还原出对象图谱。\n该技术使用在套接字间的通信，远程方法调用及轻量级的数据存储")]),n._v(" "),_("p",[n._v("并发编程")]),n._v(" "),_("p",[n._v("位操作 与或非 异或\n位移操作 左移操作  无符号左移 无符号右移")]),n._v(" "),_("p",[n._v("String 不可边类 基础类型的Wrapper也是")]),n._v(" "),_("p",[n._v("部署\n开发编写的类如何在客户端电脑运行？\n通过JAVA中的jar命令将类打包成JAR包。\n对于GUI类的程序，需要在客户端运行JAR，因此客户端需要安装JRE。对于服务器端应用，在服务器中运行JAR，服务器中需要安装JRE。两者都通过Java -jar运行程序。")]),n._v(" "),_("p",[n._v("在打成JAR包时，需要创建Manifest. txt文件指定main函数所在的类，注意行尾按enter键。最终打成的JAR包并不包含该文件，而是包含同名的. MF文件，它将内容复制过去。")]),n._v(" "),_("p",[n._v("我们打包的文件都是class文件，我们并不希望将源代码直接打包进去。那在编译的时候需要指定编译后的文件存放的目录，默认情况下，编译后的类文件存放在和当前目录，因为当前目录是添加到类类路径中的")]),n._v(" "),_("p",[n._v("当我们进入源代码目录进行编译时，源代码和类将混在一个目录中，那么打包的时候自然还要挑选出class文件，常规的做法是一开始就将类文件的路径和源文件的路径分开，可以新建一个类文件存放的文件夹，如classes文件夹，在编译的时候进入源代码文件目录，通过-d命令指定编译的目标输出文件夹，在打包的时候进入类文件夹打包即可。")]),n._v(" "),_("p",[n._v("关于包package\n不同的开发人员可能会写出一样的类名，在第三方引入同名类将发生冲突，因此需要引入包的概念，简单理解就是命名空间，一般用点号分隔，然而只有包名唯一才能保证\n类唯一，因此采用反向书写的域名来作为包名，因为域名是唯一的。")]),n._v(" "),_("p",[n._v("引入包名对于类的编译和打包都会产生影响，因为JAVA需要查找源代码和类文件的位置，当引入了包名后，JAVA会去对应包名的文件夹目录中去查找，因此在编译和打包时都会产生对应包名的文件夹。")]),n._v(" "),_("p",[n._v("Object中的方法\n定义等价关系的equal方法\nequals契约\n自反性 我还是那个我\n对称性 我就是你 你就是我\n传递性 我是你 你是他 我是他\n一致性 我现在是你 我永远都是你")])])}),[],!1,null,null,null);v.default=t.exports}}]);