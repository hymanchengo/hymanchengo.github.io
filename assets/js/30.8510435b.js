(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{591:function(v,_,n){"use strict";n.r(_);var t=n(4),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,n=v._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[n("h2",{attrs:{id:"控制反转"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#控制反转"}},[v._v("#")]),v._v(" 控制反转")]),v._v(" "),n("p",[v._v("软件工程中，控制反转(IoC)是一个编程原则。与传统控制流相比，IoC反转了控制流。IoC中，计算机程序中自定义编写的部分接收通用框架的控制流。和传统的过程式编程相比，使用该设计的软件架构\n反转了控制：在传统编程中，表达程序目的的自定义代码调用可重用的类库来处理通用任务，但是控制反转中，是框架调用自定义或特定任务的代码。")]),v._v(" "),n("p",[v._v("控制反转用增加程序的模块化和可扩展性，在面向对象编程和其他编程范式中都有应用。")]),v._v(" "),n("p",[v._v("这个术语与依赖倒置原则相关，但又不同，依赖倒置关注的是通过共享的抽象来解耦高层和底层的依赖。一般概念也和事件驱动编程相关，因为它经常使用IoC实现的，因此定制代码通常只关注于事件的处理，\n而事件循环和事件/消息的分发由框架或者运行时环境处理。")]),v._v(" "),n("p",[v._v("例如，传统编程中，应用的main函数可能调用菜单库中的函数显示可用的命令列表并询问用户选择一个。然后类库返回选中的项作为函数调用的值，main函数使用这个值来执行相关的命令。这种风格常见于基于\n文本的接口。")]),v._v(" "),n("p",[v._v("例如邮件客户端列出加载邮件、回复当前邮件，新邮件等命令提示程序执行会阻塞直到用户按键选择了一个命令。")]),v._v(" "),n("p",[v._v("另一方面，通过控制反转，程序将使用软件框架编写，框架知道通用行为和图形元素，比如窗口系统，菜单，控制鼠标等等。定制代码为框架填充空格，例如提供一个菜单项表，为每个\n菜单项注册一个代码子程序。但框架负责监视用户行为，且菜单项被选中时调用子程序。在邮件客户端例子中，框架密切注意键盘和鼠标的输入，并调用用户通过键盘或鼠标触发的命令，\n与此同时监视网络接口查看是否有新消息到来，在监测到网络活动时刷新屏幕。同样的框架可用于电子表格或文本编辑器的程序骨架。相反，框架对web浏览器，电子表格或文本编辑器一无所知，\n需要定制代码实现这些功能。")]),v._v(" "),n("p",[v._v("控制反转传达了强烈的内涵，即可重用的代码和问题特定的代码可以独立开发，即便他们在同一个应用中协同。回调，调度器，事件循环，依赖注入和模板方法都是遵循控制反转原则的\n设计模式的例子。")]),v._v(" "),n("p",[v._v("控制反转服务于如下设计意图:")]),v._v(" "),n("ul",[n("li",[v._v("将任务的执行与实现解耦")]),v._v(" "),n("li",[v._v("将模块专注在为它设计的任务上")]),v._v(" "),n("li",[v._v("将模块关于其它系统将如何执行它们的任务的假设中解放出来，取而代之的是依赖契约")]),v._v(" "),n("li",[v._v("避免替换模块时的副作用")])]),v._v(" "),n("p",[v._v("控制反转有时被戏剧性地称为好莱坞原则：不要打电话给（调用）我们，我们会打电话给(调用)你。Don't call us, we'll call you.")]),v._v(" "),n("p",[v._v("依赖注入是一种特定类型的控制反转。诸如JNDI(Java Naming And Directory Interface)的服务定位器(service locator)也是类似的控制反转。")]),v._v(" "),n("p",[v._v("在传统编程中，业务逻辑流程是由静态绑定到彼此的对象确定。在控制反转中，流程依赖于程序执行期间构建出的对象图。这样的动态流是由抽象定义的对象交互来实现的。\n这种运行时绑定是通过诸如依赖注入或服务定位器这样的机制实现的。控制反转中，代码也可以在编译期间静态连接，但是通过从外部配置中读取描述查找要执行的代码，而不是直接引用\n代码本身。")]),v._v(" "),n("p",[v._v("在依赖注入中，依赖对象或模块在运行期和它依赖的对象耦合。在程序执行期间满足依赖的特定对象通常不可能在编译期通过静态分析得知。")]),v._v(" "),n("p",[v._v("实现技术\n在面向对象编程中，有几个基本技术实现控制反转：")]),v._v(" "),n("ul",[n("li",[v._v("使用服务定位器模式")]),v._v(" "),n("li",[v._v("使用依赖注入\n"),n("ul",[n("li",[v._v("构造函数注入")]),v._v(" "),n("li",[v._v("参数注入")]),v._v(" "),n("li",[v._v("Setter注入")]),v._v(" "),n("li",[v._v("接口注入")])])]),v._v(" "),n("li",[v._v("使用上下文化的查找")]),v._v(" "),n("li",[v._v("使用模板方法设计模式")]),v._v(" "),n("li",[v._v("使用策略设计模式")])]),v._v(" "),n("p",[v._v("参考\n"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Inversion_of_control",target:"_blank",rel:"noopener noreferrer"}},[v._v("Wiki IoC"),n("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=e.exports}}]);