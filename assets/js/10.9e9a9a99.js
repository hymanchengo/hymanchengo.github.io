(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{504:function(t,a,n){t.exports=n.p+"assets/img/geek_algorithm.913e0aba.jpg"},505:function(t,a,n){t.exports=n.p+"assets/img/line.2fb4753c.jpg"},506:function(t,a,n){t.exports=n.p+"assets/img/notline.01993ace.jpg"},590:function(t,a,n){"use strict";n.r(a);var s=n(4),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"数据结构与算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构与算法"}},[t._v("#")]),t._v(" 数据结构与算法")]),t._v(" "),s("h2",{attrs:{id:"why"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#why"}},[t._v("#")]),t._v(" why")]),t._v(" "),s("ul",[s("li",[t._v("大厂面试")]),t._v(" "),s("li",[t._v("现代流行框架及中间件")]),t._v(" "),s("li",[t._v("日常开发正确选用")]),t._v(" "),s("li",[t._v("为编写开源框架打基础")])]),t._v(" "),s("h2",{attrs:{id:"how-to-learn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-to-learn"}},[t._v("#")]),t._v(" how to learn")]),t._v(" "),s("h3",{attrs:{id:"学习方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习方法"}},[t._v("#")]),t._v(" 学习方法")]),t._v(" "),s("ul",[s("li",[t._v("找重点、不要死记硬背、学习数据结构和算法的来历，特点，解决什么问题，实际应用场景。")]),t._v(" "),s("li",[t._v("思维锻炼、多问为什么，多思考。与他人交流。")]),t._v(" "),s("li",[t._v("边学边练，适度刷题。代码实现。多写多练，没有捷径。\n"),s("ul",[s("li",[t._v("方法和技巧")]),t._v(" "),s("li",[t._v("坚持")])])]),t._v(" "),s("li",[t._v("立flag，打怪升级")]),t._v(" "),s("li",[t._v("知识需要沉淀，不要试图一下子掌握所有，需要反复及沉淀")]),t._v(" "),s("li",[t._v("最后这些学习方法迁移到其他技术的学习中。")])]),t._v(" "),s("h3",{attrs:{id:"数据结构和算法目标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法目标"}},[t._v("#")]),t._v(" 数据结构和算法目标")]),t._v(" "),s("p",[t._v("更快，更省")]),t._v(" "),s("h3",{attrs:{id:"数据结构和算法中的思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法中的思想"}},[t._v("#")]),t._v(" 数据结构和算法中的思想")]),t._v(" "),s("ul",[s("li",[t._v("双向链表数据结构使用了空间换时间的思想")]),t._v(" "),s("li",[t._v("递归")]),t._v(" "),s("li",[t._v("分治")])]),t._v(" "),s("h3",{attrs:{id:"数据结构和算法衡量-重点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法衡量-重点"}},[t._v("#")]),t._v(" 数据结构和算法衡量（重点）")]),t._v(" "),s("p",[t._v("复杂度分析")]),t._v(" "),s("h3",{attrs:{id:"重点学习的数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重点学习的数据结构"}},[t._v("#")]),t._v(" 重点学习的数据结构")]),t._v(" "),s("ul",[s("li",[t._v("数组")]),t._v(" "),s("li",[t._v("链表")]),t._v(" "),s("li",[t._v("栈")]),t._v(" "),s("li",[t._v("队列")]),t._v(" "),s("li",[t._v("散列表")]),t._v(" "),s("li",[t._v("二叉树")]),t._v(" "),s("li",[t._v("堆")]),t._v(" "),s("li",[t._v("跳表")]),t._v(" "),s("li",[t._v("图")]),t._v(" "),s("li",[t._v("Trie树")])]),t._v(" "),s("h3",{attrs:{id:"重点学习的算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重点学习的算法"}},[t._v("#")]),t._v(" 重点学习的算法")]),t._v(" "),s("ul",[s("li",[t._v("递归")]),t._v(" "),s("li",[t._v("排序")]),t._v(" "),s("li",[t._v("二分查找")]),t._v(" "),s("li",[t._v("搜索")]),t._v(" "),s("li",[t._v("哈希算法")]),t._v(" "),s("li",[t._v("贪心算法")]),t._v(" "),s("li",[t._v("分治算法")]),t._v(" "),s("li",[t._v("回溯算法")]),t._v(" "),s("li",[t._v("动态规划算法")]),t._v(" "),s("li",[t._v("字符串匹配算法")])]),t._v(" "),s("h3",{attrs:{id:"算法技巧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法技巧"}},[t._v("#")]),t._v(" 算法技巧")]),t._v(" "),s("ul",[s("li",[t._v("链表\n"),s("ul",[s("li",[t._v("理解指针，指针的值就是另一个结点的地址。")]),t._v(" "),s("li",[t._v("防止指针丢失（如x->y->z。删除y时x->next = y->next; y->next = null;这两个操作顺序不能颠倒 ）和内存泄露（删除结点，结点指针未设为null）")]),t._v(" "),s("li",[t._v("使用哨兵结点（无数据结点，head=null）统一实现逻辑，屏蔽头尾结点的特殊处理（有哨兵结点的链表称为带头链表）")]),t._v(" "),s("li",[t._v("检查边界条件处理，如无结点、1个结点，2个结点的场景")]),t._v(" "),s("li",[t._v("复杂的场景使用示意图。")])])])]),t._v(" "),s("h3",{attrs:{id:"概览"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[t._v("#")]),t._v(" 概览")]),t._v(" "),s("p",[s("img",{attrs:{src:n(504),alt:""}})]),s("div",{staticStyle:{"text-align":"center","font-size":"14px",color:"#C0C0C0","text-decoration":"underline"}},[t._v("引自https://time.geekbang.org/column/article/40011")]),s("p"),t._v(" "),s("h2",{attrs:{id:"what"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what"}},[t._v("#")]),t._v(" what")]),t._v(" "),s("h3",{attrs:{id:"数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),s("p",[t._v("数据的存储结构")]),t._v(" "),s("h3",{attrs:{id:"线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[t._v("#")]),t._v(" 线性表")]),t._v(" "),s("p",[t._v("线性表上的数据最多只有前后两个方向。如下图所示\n"),s("img",{attrs:{src:n(505),alt:""}})]),s("div",{staticStyle:{"text-align":"center","font-size":"14px",color:"#C0C0C0","text-decoration":"underline"}},[t._v("引自https://time.geekbang.org/column/article/40961")]),s("p"),t._v(" "),s("h4",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),s("blockquote",[s("p",[t._v("数组为什么从0开始编号，而不是更符合人类直觉的1？")])]),t._v(" "),s("p",[t._v("数组特性")]),t._v(" "),s("ul",[s("li",[t._v("线性数据结构")]),t._v(" "),s("li",[t._v("连续的内存空间")]),t._v(" "),s("li",[t._v("存储相同类型的数据")]),t._v(" "),s("li",[t._v("随机访问")]),t._v(" "),s("li",[t._v("插入，删除低效\n"),s("ul",[s("li",[t._v("根据考虑插入位置，探讨")]),t._v(" "),s("li",[t._v("尾插/删：最好时间复杂度O(1)")]),t._v(" "),s("li",[t._v("头插/删：最坏时间复杂度O(n)")]),t._v(" "),s("li",[t._v("平均时间复杂度(1+..+n)/n = O(n)")]),t._v(" "),s("li",[t._v("在特殊场景下，可以优化插入，如在k位置插入一个新元素，可以将新元素插入k位置，而k位置原先的元素直接移到数组末尾。这样复杂度为O(1)")]),t._v(" "),s("li",[t._v("在特殊场景下，可以优化删除，标记删除元素，而不立即删除，等数据大小不够用时触发删除，这样避免频繁移动元素。这样复杂度为O(1)。这和jvm gc Mark-Sweep算法核心思想一致。")])])])]),t._v(" "),s("p",[t._v("数组为什么可以随机访问？\n因为连续的内存空间和相同类型数据这2个特性使得任何一个数组元素的存储地址可以被直接计算出，因此可以直接访问。\n因此第n个元素存储地址的计算：初始地址 + (n * 1个数据元素占据地址范围)。第一个元素地址就是初始地址，因此n取0。如果n从1开始编号，则计算每个元素存储地址的时候需要额外进行n-1的计算。")]),t._v(" "),s("p",[t._v("数组相关时间复杂度")]),t._v(" "),s("ul",[s("li",[t._v("随机访问O(1)")])]),t._v(" "),s("p",[t._v("C语言数组越界问题\n由于C语言直接访问内存，下面示例数组越界访问"),s("code",[t._v("arr[3]")]),t._v("，如果这个内存存放的是i，那么i又被置为0，戏剧的事情发生了，就会一直循环下去。")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" argc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" argv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//arr长度为3")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// i 从0到3。3的时候越界")]),t._v("\n        arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello world\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Java ArrayList与数组\nJava中的ArrayList是数组实现的。它的优点是提供了丰富的操作数组的API，使用者无需关系数组越界，容量不够的问题。容量不够时会自动进行扩容。"),s("br"),t._v("\n数组相较于ArrayList的使用场景\n- 性能要求高，直接使用数组\n- 基础数据类型，使用数组\n- 简单数组操作")]),t._v(" "),s("p",[t._v("Java中数组为什么限制大小为"),s("code",[t._v("private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;")]),t._v(" 通过length属性可以看到定义为int。那为什么不定义long？\nInteger.MAX_VALUE为2^31，约2G。我们pc内存常见有4G,8G,16G等。如果用long表示数组大小，那可表示的内存大小远远超过我们现在使用的内存，完全没有必要。")]),t._v(" "),s("h4",{attrs:{id:"链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),s("p",[t._v("经典使用场景：LRU缓存淘汰算法")]),t._v(" "),s("blockquote",[s("p",[t._v("缓存：提高数据读取性能的常用技术，常见的有CPU 1,2,3级缓存。内存缓存。浏览器缓存。")])]),t._v(" "),s("p",[t._v("缓存通常都不会太大，因此当缓存满了，按照什么策略进行清理呢？常见的有先进先出FIFO,最少使用LFU,最近最少使用LRU。\n类比对衣橱里的衣服进行整理，为新买衣服腾空间，最常见的就是把最早买的那批先打包，因为旧了。其次对不怎么想穿的进行打包，最后最近不怎么用到的打包，比如冬天了，夏天的衣服就先打包。")]),t._v(" "),s("p",[t._v("链表vs数组")]),t._v(" "),s("ul",[s("li",[t._v("内存利用率\n数组需要连续存储空间，而链表则不需要，链表用指针串起元素结点，那么链表较数组可以利用碎片内存空间，内存利用率高。")]),t._v(" "),s("li",[t._v("性能\n"),s("ul",[s("li",[t._v("数组查找性能高O(1)，链表查找性能低O(n)")]),t._v(" "),s("li",[t._v("数组插入、删除性能低O(n)，链表插入删除性能高O(1)")]),t._v(" "),s("li",[t._v("因为数组是连续的内存空间，对于CPU缓存较为友好，因为CPU缓存可以轻易读入一段连续空间。而链表因为内存空间不连续，则CPU一次读取，可能不能加载整个链表（寻址）。")])])]),t._v(" "),s("li",[t._v("动态扩展性\n"),s("ul",[s("li",[t._v("创建新数组需要定义大小，如果事先知道所需的尺寸，按需申请是没问题，一旦不能或错误估计数组大小，那么要么空间申请大了浪费，要么申请小了，需要动态扩容并拷贝，效率低。链表的结构则更为灵活，\n天然支持动态扩展。")])])]),t._v(" "),s("li",[t._v("内存碎片\n"),s("ul",[s("li",[t._v("链表频繁插入，删除，可能导致更多的内存碎片，需要更频繁的gc。\n链表术语\n结点：链表上的每个内存块，包括数据和指针两部分\n后继指针next：结点中指向下个内存块地址的部分")])])])]),t._v(" "),s("p",[t._v("链表种类")]),t._v(" "),s("ul",[s("li",[t._v("单链表\n"),s("ul",[s("li",[t._v("不同节点个数的链表\n"),s("ul",[s("li",[t._v("0个结点：空链表")]),t._v(" "),s("li",[t._v("1个结点：结点指针不指向任何其他结点，指针为NULL。1个结点既是头结点，也是尾结点。头结点记录链表基地址")]),t._v(" "),s("li",[t._v("2个结点：头结点指向尾结点")]),t._v(" "),s("li",[t._v("3个以上节点：头结点只有后继结点，中间结点有前驱和后继节点，尾结点只有前驱结点")])])]),t._v(" "),s("li",[t._v("特性\n"),s("ul",[s("li",[t._v("插入/删除\n"),s("ul",[s("li",[t._v("时间复杂度O(1)，(这边的时间复杂度不包括查找的复杂度) 在x->z链表中插入y, x->y, y->z，在x->y->z链表中删除y,x->z, y->null")])])]),t._v(" "),s("li",[t._v("访问\n"),s("ul",[s("li",[t._v("时间复杂度O(n)")])])])])])])]),t._v(" "),s("li",[t._v("循环链表\n"),s("ul",[s("li",[t._v("原先单链表的尾结点指向头结点形成了循环链表，循环链表每个结点都有前驱和后继结点。")]),t._v(" "),s("li",[t._v("约瑟夫问题")])])]),t._v(" "),s("li",[t._v("双向链表\n"),s("ul",[s("li",[t._v("每个结点有两个指针，分别指向前驱结点和后继结点，因此比存储相同数据的单链表更加占用空间。")]),t._v(" "),s("li",[t._v("可以按两个方向遍历链表\n"),s("ul",[s("li",[t._v("给定结点，删除（插入）其前驱结点，双向链表通过前驱指针即可定位到前驱结点，时间复杂度O(1)，而单链表则需从链表头部开始查找，时间复杂度O(n)")]),t._v(" "),s("li",[t._v("给定值，删除（插入）其前驱，则单链表和双向链表则要从头遍历找出值等于给定值的节点进行操作，时间复杂度都为O(n)")])])]),t._v(" "),s("li",[t._v("体现了空间换时间的思想\n"),s("ul",[s("li",[t._v("缓存也体现了空间换时间")])])])])]),t._v(" "),s("li",[t._v("双向循环链表")])]),t._v(" "),s("p",[t._v("Java中LinkedHashMap")]),t._v(" "),s("h4",{attrs:{id:"栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),s("p",[t._v("栈可以形象理解为将洗碗池的盘子堆起来然后再将盘子一一摆到桌子上的过程。\n栈特性：先进后出、后进先出\n栈是操作受限的线性表，只能单端压入，弹出元素。\n栈完全可以用数组和链表模拟，为什么还提供栈这种数据结构？栈又适用于哪些场景？")]),t._v(" "),s("h4",{attrs:{id:"队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),s("p",[t._v("线程池设定多大合适？是不是越大越好？\n是不是线程数越多，任务处理越快？这不是简单的线性关系，因为受CPU资源的限制。我们可以想象，在CPU资源空闲时间，任务处理速度和线程数呈线性关系。当CPU占用率达到一定的数值后，线性关系便不能满足，\n而且由于线程数目的增加，导致CPU频繁切换。性能下降。\n因此线程池的大小需要综合考虑处理的任务特点和硬件环境来事先设置。\n队列在生活中经常看到，如典型的排队打饭场景。\n队列特性：先进先出。\n队列也是操作受限的数据结构，队尾入队，队头出队。\n队列分类")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("顺序队列\n用数组实现的队列\n用2个指针，1个执行队头，一个指向队尾。当出队时移动队头指针，当入队时移动队尾指针，当队尾指针移到数组最大长度时，将没有空间，此时可以触发一下数据搬移，将队头到队尾的这部分元素搬移到数组开始后连续的\n位置，这样出队后入队的时间复杂度都是O(1)（出队的时间复杂度用均摊法计算出来为O(1)）")])]),t._v(" "),s("li",[s("p",[t._v("链式队列\n用链表实现的队列。依然使用2个指针。")])]),t._v(" "),s("li",[s("p",[t._v("循环队列。考虑队空（head = tail），队满的判定条件(tail + 1) % n = head\n解决顺序队列需要搬移数据的问题。\n特性队列")])]),t._v(" "),s("li",[s("p",[t._v("阻塞队列")]),t._v(" "),s("ul",[s("li",[t._v("队头无元素可取，阻塞")]),t._v(" "),s("li",[t._v("队尾无位置可入队，阻塞")]),t._v(" "),s("li",[t._v("阻塞队列实现生产者消费者模型。\n"),s("ul",[s("li",[t._v("消费者从队头取数据，没有则阻塞等待。")]),t._v(" "),s("li",[t._v("生产者从队尾放数据，没有位置则等待。说明消费不过来。")]),t._v(" "),s("li",[t._v("使用n个消费者，1个生产者的模式提示数据处理效率。")])])])])]),t._v(" "),s("li",[s("p",[t._v("并发队列")]),t._v(" "),s("ul",[s("li",[t._v("支持多线程环境操作的队列。")]),t._v(" "),s("li",[t._v("线程安全的队列")]),t._v(" "),s("li",[t._v("实现方式\n"),s("ul",[s("li",[t._v("入队，出队加锁。粒度太大")]),t._v(" "),s("li",[t._v("基于数组的循环队列，利用CAS操作\n对于资源优先的池，如线程池，数据库连接池，当无可用资源时，陆续到来的请求可以使用队列来实现请求排队，对于链表实现的队列是无界队列，请求队列可能相对较长，导致响应时间长，\n对于数组实现的队列，是有界队列，当排队的请求塞满队列时，后面的请求可以直接拒绝。")])])])])])]),t._v(" "),s("h3",{attrs:{id:"非线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非线性表"}},[t._v("#")]),t._v(" 非线性表")]),t._v(" "),s("p",[t._v("数据之间并非简单的前后关系，如下图所示\n"),s("img",{attrs:{src:n(506),alt:""}})]),t._v(" "),s("h2",{attrs:{id:"算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),s("p",[t._v("操作数据的方法")]),t._v(" "),s("h3",{attrs:{id:"数据结构与算法关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构与算法关系"}},[t._v("#")]),t._v(" 数据结构与算法关系")]),t._v(" "),s("ul",[s("li",[t._v("相辅相成，算法作用于特定的数据结构。也依托于特定数据结构（如二分查找依托数组的随机访问特性，而不能作用于链表上）。")]),t._v(" "),s("li",[t._v("不同数据结构产生的算法也不同。")]),t._v(" "),s("li",[t._v("数据结构可以类比为存储，算法类比为计算。")]),t._v(" "),s("li",[t._v("数据结构是静态的，算法是盘活数据结构的关键。")]),t._v(" "),s("li",[t._v("数据结构提供数据存储的方式，算法提供操作数据的方式。")])]),t._v(" "),s("h3",{attrs:{id:"复杂度分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[t._v("#")]),t._v(" 复杂度分析")]),t._v(" "),s("p",[t._v("衡量算法执行效率的指标：时间、空间复杂度分析"),s("br"),t._v("\nwhy复杂度分析？")]),t._v(" "),s("ul",[s("li",[t._v("事后统计法的局限\n"),s("ul",[s("li",[t._v("测试结果依赖测试环境，如代码在i3和i9上跑的结果比对")]),t._v(" "),s("li",[t._v("测试结果受规模影响大。如待排序数据的规模可能对评估算法的优劣产生不同的结果。另外排序数据有序性对算法评估也有影响。\n因此，基于事后统计法，即在实际机器上跑一下代码统计时空消耗的方法有诸多局限，我们需要粗略估计算法执行效率的方法")])])]),t._v(" "),s("li",[t._v("大O复杂度表示法（或渐进时间复杂度）（简称时间复杂度）"),s("br"),t._v("\n给定如下代码，假定每行代码执行耗时一样（记作u），那么耗时2nu + 2u，总执行时间T(n)与每行代码执行次数成正比。")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1u")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1u")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// nu")]),t._v("\n     sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// nu")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("根据上面分析，下面这段代码执行耗时(3 + n + n + n^2 + n^2)u = (2n^2 + 2n + 3)u")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("  i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("从上面2段代码总结规律：所有代码的执行时间T(n)与每行代码执行次数f(n)成正比。T(n) = O(f(n))。O表示正比关系。\n因此上面2段代码耗时用公式分别表示为T(n) = O(2n + 2), T(n) = O(2n^2 + 2n + 3)。进一步，如果n足够大，低阶、常量、系数等不足以影响复杂度的整个走势，因此上面2段代码\n时间复杂度可进一步表示我T(n) = O(n), T(n) = O(n^2)。"),s("br"),t._v("\n大O时间复杂度并不具体表示代码真正执行时间，而是表示代码执行时间随数据规模增长的变化趋势。")]),t._v(" "),s("ul",[s("li",[t._v("时间复杂度分析的实用方法\n"),s("ul",[s("li",[t._v("只关注循环次数执行最多的一段代码")]),t._v(" "),s("li",[t._v("加法法则T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))。需要注意不管常量循环的次数有多大，它不反应增长趋势，即便常量1000>n^2，复杂度依然取n^2\n"),s("ul",[s("li",[t._v("当有2个数据规模的循环时，如m和n,因为不知道哪个数量级大，不能随意取其中一个，因此加法的算法复杂度表示为O(m + n)")])])]),t._v(" "),s("li",[t._v("乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))")])])]),t._v(" "),s("li",[t._v("常见的时间复杂度量级\n"),s("ul",[s("li",[t._v("多项式量级\n"),s("ul",[s("li",[t._v("常量阶O(1)\n"),s("ul",[s("li",[t._v("常量级时间复杂度")]),t._v(" "),s("li",[t._v("表示代码执行时间不随n的增大而增长的时间复杂度")]),t._v(" "),s("li",[t._v("若代码中不存在循环、递归等，即便上千上万行代码依然是O(1)复杂度")])])]),t._v(" "),s("li",[t._v("对数阶O(logn)\n这边很多人可能有疑问这个logn是以多少为底的，实际上并不重要。统一记作logn。因为对数间可以转换如log3(n) = log3(2) * log2(n)，而log3(2)是个常数，可以忽略。因此以对数阶复杂度"),s("br"),t._v("\n我们直接忽略底数，记作O(logn)")]),t._v(" "),s("li",[t._v("线性阶O(n)")]),t._v(" "),s("li",[t._v("线性对数阶O(nlogn)\n"),s("ul",[s("li",[t._v("理解O(nlogn)，可以想象外层n次循环，内层的时间复杂度是O(logn)，这样总复杂度就是O(nlogn)")]),t._v(" "),s("li",[t._v("示例\n"),s("ul",[s("li",[t._v("归并排序")]),t._v(" "),s("li",[t._v("快速排序")])])])])]),t._v(" "),s("li",[t._v("平方阶O(n^2)")]),t._v(" "),s("li",[t._v("立方阶O(n^3)")]),t._v(" "),s("li",[t._v("k次方阶O(n^k)")])])]),t._v(" "),s("li",[t._v("非多项式量级\n非多项式量级的算法问题成为NP（None-Deterministic Polynomial非确定多项式）问题。随着n的增大，算法执行时间急剧增加，算法效率极其低下。\n"),s("ul",[s("li",[t._v("指数阶O(2^n)")]),t._v(" "),s("li",[t._v("阶乘阶O(n!)")])])])])]),t._v(" "),s("li",[t._v("空间复杂度（渐近空间复杂度）\n表示算法的存储空间与数据规模的增长关系\n常用空间复杂度O(1),O(n),O(n^2)")]),t._v(" "),s("li",[t._v("考量几个典型的算法复杂度\n考虑如下代码")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// n表示数组array的长度, 返回无序数组中指定元素的位置")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("find")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" pos "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        pos "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" pos"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("正常情况不需要区分最好，最坏，平均时间复杂度。只有存在量级差距时才进行区分。")]),t._v(" "),s("ul",[s("li",[t._v("最好情况时间复杂度\n最理想情况下，元素x出现在数组中的第一个位置处：O(1)")]),t._v(" "),s("li",[t._v("最坏情况时间复杂度\n最糟糕情况下，元素x不存在于数组中：O(n)")]),t._v(" "),s("li",[t._v("平均情况时间复杂度（加权平均时间复杂度）\n考虑最好情况和最坏情况出现的概率不大，因此引入平均情况时间复杂度：\n不考虑概率：(1（在第一个位置） + 2 + ... + n  + n（不在数组中）) / (n + 1) = (n^2 + 3n ) /2(n + 1)，简化后为O(n)\n考虑概率：每个位置出现的概率为1/2n。那么"),s("code",[t._v("1*1/2n + 2*1/2n+...+ n*1/2n + n*1/2")]),t._v("=(3n+1)/4，该值为加权平均值（期望值），复杂度依然是O(n)")]),t._v(" "),s("li",[t._v("均摊时间复杂度\n用另一段代码理解均摊时间复杂度。这段代码用概率论可以分析，不用概率率也可以，因为它是有规律的。对于前n次插入复杂度是O(1)，对于n+1次复杂度为O(n).\n因此这一次的复杂度可以均摊到前n次中。因此整个复杂度就是O(1)。"),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// array表示一个长度为n的数组")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码中的array.length就等于n")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" array "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("count "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      count "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n    array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("count"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("count"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])]),t._v(" "),s("p",[t._v("平均复杂度和均摊复杂度容易混淆，但均摊复杂度适用场景更小。对于上面示例这种大部分情况复杂度低，偶尔一次复杂度高，且它们之间出现有序时，才会使用均摊复杂度。")]),t._v(" "),s("h3",{attrs:{id:"递归算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归算法"}},[t._v("#")]),t._v(" 递归算法")]),t._v(" "),s("p",[t._v("递归就像梦中梦，从现实进入一层梦，继而二层梦，，再层层回来就，回到二层梦，再回到现实。")]),t._v(" "),s("p",[t._v("递归问题本质上是将一个大问题逐层分解为较小的子问题，这个分解问题的过程可以理解为递，直到递终止，然后由最里层逐层返回计算结果，直到最外层计算完毕，这个\n结果逐层返回的过程，可以认为是归。")]),t._v(" "),s("p",[t._v("我们较为熟悉的递归问题有爬楼梯问题，斐波那契数列，系统菜单的展示算法，Java程序方法的递归调用本质上是方法栈帧的不断压栈，所以如果递归层次太深，可能会引起栈溢出的错误。\n对于递归除了需要注意栈溢出，递归常常会存在重复计算。可以使用hash表将之前计算的结果存起来，以空间换区时间。")]),t._v(" "),s("p",[t._v("我们写递归常见的思维误区是人肉递归，常常发生脑容量溢出的奇效。因此面对一个递归，我们首先写好递归终止条件，然后写递归公式即可。")]),t._v(" "),s("h4",{attrs:{id:"递归需要满足的三个条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归需要满足的三个条件"}},[t._v("#")]),t._v(" 递归需要满足的三个条件")]),t._v(" "),s("ul",[s("li",[t._v("一个问题的解可以分为几个子问题的解")]),t._v(" "),s("li",[t._v("这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样")]),t._v(" "),s("li",[t._v("存在递归终止条件")])]),t._v(" "),s("h4",{attrs:{id:"递归的优缺点及改写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归的优缺点及改写"}},[t._v("#")]),t._v(" 递归的优缺点及改写")]),t._v(" "),s("p",[t._v("优点是代码编写简洁。缺点是可能导致栈溢出，重复计算，函数调用耗时，空间复杂度高。\n递归代码一般总是可以转换为非递归代码。递归本质上可以理解为循环，它的层可以转换为循环的次数，而每层的计算可以理解为循环计算的内容，只不过每层计算的结果\n需要额外通过变量记录，以便下次循环使用。")]),t._v(" "),s("h3",{attrs:{id:"排序算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序算法"}},[t._v("#")]),t._v(" 排序算法")]),t._v(" "),s("p",[t._v("顺序表示一种秩序，通常是人们出于统计目的对一组值进行按照特定大小，先后规则进行调整，以达到特定维度观察事物，对未来进行预估的目的。比如对最近一周温度排序，以\n查看最高温度和最低温度，对一组学生的成绩进行排序以确定第一名等。")]),t._v(" "),s("h4",{attrs:{id:"如何分析排序算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何分析排序算法"}},[t._v("#")]),t._v(" 如何分析排序算法")]),t._v(" "),s("ul",[s("li",[t._v("排序算法的执行效率衡量点\n"),s("ul",[s("li",[t._v("最好、最好、最坏情况时间复杂度")]),t._v(" "),s("li",[t._v("时间复杂度的系数、常数、低阶\n"),s("ul",[s("li",[t._v("当对同阶时间复杂度的排序算法性能比对时考虑")])])]),t._v(" "),s("li",[t._v("比较次数、交换(或移动)次数")])])]),t._v(" "),s("li",[t._v("排序算法的内存消耗\n"),s("ul",[s("li",[t._v("原地排序：空间复杂度O(1)")])])]),t._v(" "),s("li",[t._v("排序算法的稳定性\n值相等的元素，经过算法的排序后，能保持其顺序的就是稳定算法\n"),s("ul",[s("li",[t._v("订单按照金额从小到大排序，对于相同金额的订单按照下单时间从早到晚排序。\n"),s("ul",[s("li",[t._v("可以按照时间从早到晚先排序，然后利用稳定的排序算法对金额从小到大排序。")])])])])]),t._v(" "),s("li",[t._v("引入有序度和乱序度分析平均时间复杂度\n有序度是具有有序关系的元素对个数\n一组数1,2,3,4,5,6可以组合成(1,2),(1,3),.........15个序对 n*(n - 1) /2\n如果全部正序，则有序度为15（满有序度），逆序度为0，如果全部逆序，则有序度为0，逆序度为15。\n排序的过程可以理解为减少逆序度，增加逆序度到满有序度的过程。")]),t._v(" "),s("li",[t._v("各排序算法时间复杂度、稳定性等总结")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("排序算法")]),t._v(" "),s("th",[t._v("原地排序算法")]),t._v(" "),s("th",[t._v("稳定排序算法")]),t._v(" "),s("th",[t._v("最好时间复杂度")]),t._v(" "),s("th",[t._v("最坏时间复杂度")]),t._v(" "),s("th",[t._v("平均时间复杂度")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("冒泡排序")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("O(n)")]),t._v(" "),s("td",[t._v("O(n^2)")]),t._v(" "),s("td",[t._v("O(n^2)")])]),t._v(" "),s("tr",[s("td",[t._v("插入排序")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("O(n)")]),t._v(" "),s("td",[t._v("O(n^2)")]),t._v(" "),s("td",[t._v("O(n^2)")])]),t._v(" "),s("tr",[s("td",[t._v("选择排序")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("O(n^2)")]),t._v(" "),s("td",[t._v("O(n^2)")]),t._v(" "),s("td",[t._v("O(n^2)")])]),t._v(" "),s("tr",[s("td",[t._v("归并排序")]),t._v(" "),s("td",[t._v("否（空间复杂度O(n)）")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("O(nlogn)")]),t._v(" "),s("td",[t._v("O(nlogn)")]),t._v(" "),s("td",[t._v("O(nlogn)")])]),t._v(" "),s("tr",[s("td",[t._v("快速排序")]),t._v(" "),s("td",[t._v("是")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("O(nlogn)")]),t._v(" "),s("td",[t._v("O(n^2)")]),t._v(" "),s("td",[t._v("O(nlogn)")])])])]),t._v(" "),s("p",[t._v("按算法时间复杂度大致分为3类")]),t._v(" "),s("h4",{attrs:{id:"o-n-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#o-n-2"}},[t._v("#")]),t._v(" O(n^2)")]),t._v(" "),s("p",[t._v("适合小规模数据的排序")]),t._v(" "),s("ul",[s("li",[t._v("冒泡排序\n"),s("ul",[s("li",[t._v("相邻元素进行大小比较，逆序则交换顺序")])])]),t._v(" "),s("li",[t._v("插入排序\n"),s("ul",[s("li",[t._v("在一个有序集合中，在能维持集合有序的位置插入新元素的思想")]),t._v(" "),s("li",[t._v("分为已排序区间和未排序区间\n"),s("ul",[s("li",[t._v("初始已排序区间里只有第一个元素")]),t._v(" "),s("li",[t._v("从未排序区间里取出一个元素，插入到正确的位置保持已排序区间的有序。重复这个过程，直到未排序区间没有元素。\n"),s("ul",[s("li",[t._v("在和已排序区间元素比较时，从头到尾和从尾到头比较，比较次数有区别")]),t._v(" "),s("li",[t._v("整个排序过程移动总次数一定，等于逆序度，每次移动的个数等于每次增加的有序度数。")])])])])])])]),t._v(" "),s("li",[t._v("选择排序\n"),s("ul",[s("li",[t._v("类似插入排序，分为已排序和未排序区间，不同的是每次从未排序区间中通过比较选出最小的，放到已排序区间末尾。")]),t._v(" "),s("li",[t._v("不是稳定排序算法，如3,3,5,1，经过第一次排序变成1,3,5,3，可以看到2个3的顺序已经变化了。")])])])]),t._v(" "),s("h4",{attrs:{id:"o-nlogn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#o-nlogn"}},[t._v("#")]),t._v(" O(nlogn)")]),t._v(" "),s("p",[t._v("适合大规模的数据排序")]),t._v(" "),s("ul",[s("li",[t._v("归并排序（Merge Sort）\n"),s("ul",[s("li",[t._v("使用分治思想")]),t._v(" "),s("li",[t._v("将待排序数据从中间一分为二，再对划分后的每个子问题再进行划分，直到不可再分，之后对划分后的最小问题单元进行比较计算，得到一个个结果集，再将这些结果集一一合并。")]),t._v(" "),s("li",[t._v("实现手段：递归"),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("递推公式：\nmerge_sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p…r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" merge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("merge_sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p…q"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(", merge_sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("q+1…r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")]),t._v("\n终止条件：\np "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" r 不用再继续分解\n")])])]),t._v("merge的方式是额外用一个临时数组存放merge结果，最后放入原数组。")]),t._v(" "),s("li",[t._v("空间复杂度O(n)")])])]),t._v(" "),s("li",[t._v("快速排序(QuickSort)\n"),s("ul",[s("li",[t._v("分治、分区思想")]),t._v(" "),s("li",[t._v("在pivot(基准)选择合理情况也就是最好时间复杂度O(nlogn)")]),t._v(" "),s("li",[t._v("在pivot选择不合理情况也就是最坏时间复杂度O(n^2)")])])])]),t._v(" "),s("h4",{attrs:{id:"o-n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#o-n"}},[t._v("#")]),t._v(" O(n)")]),t._v(" "),s("p",[t._v("线性排序，非基于比较的排序算法")]),t._v(" "),s("ul",[s("li",[t._v("桶排序\n"),s("ul",[s("li",[t._v("待排序数据分到有限的有序桶里。")]),t._v(" "),s("li",[t._v("单独对每个桶里的数据进行排序")]),t._v(" "),s("li",[t._v("依序取出桶里的数据。")]),t._v(" "),s("li",[t._v("时间复杂度为O(n)\nn个数，m个桶。每个桶k = n/m个元素，k个元素快排时间复杂度O(klogk)，每个桶总共复杂度O(mklogk)=O(nlogn/m)，当桶个数m接近n\n时，时间复杂度接近于O(n)")]),t._v(" "),s("li",[t._v("桶排序苛刻的使用场景\n"),s("ul",[s("li",[t._v("待排序数据容易分成m个桶")]),t._v(" "),s("li",[t._v("桶与桶之间有天然的大小顺序")]),t._v(" "),s("li",[t._v("各个桶里的数据分布均匀，否则退化为O(nlogn)的时间复杂度。")])])]),t._v(" "),s("li",[t._v("桶排序适合用在外部排序中，如对外部磁盘上大数据量无法一次加载到较小内存中进行排序的场景\n"),s("ul",[s("li",[t._v("用100M内存对10G订单数据进行排序。\n"),s("ul",[s("li",[t._v("扫描订单数据，确定金额范围如1~10w")]),t._v(" "),s("li",[t._v("将金额划分为100个桶。对桶进行编号，桶依次存放1~1000,1001~2000区间金额的订单等")]),t._v(" "),s("li",[t._v("将订单数据分别放入这100个桶，对应100个文件。分别对这100个文件进行排序。")]),t._v(" "),s("li",[t._v("依次读入排好序的文件，将其写入同一个文件中，这个文件存放的就是排好序的订单数据。")])])])])])])]),t._v(" "),s("li",[t._v("计数排序\n"),s("ul",[s("li",[t._v("用在数据范围不大的场景中")]),t._v(" "),s("li",[t._v("只能给非负整数排序，其他数据要转换为非负整数")])])]),t._v(" "),s("li",[t._v("基数排序\n"),s("ul",[s("li",[t._v("需要分割出独立的”位“来比较，位之间有递进关系，如a的高位比b大，剩下的低位就不用比较了。")]),t._v(" "),s("li",[t._v("每一位的数据范围不能太大，要可以使用线性排序算法来排序，否则基数排序的时间复杂度无法做到O(n)")]),t._v(" "),s("li",[t._v("对10w手机号排序，对单词进行排序（补齐0再排序）")])])])]),t._v(" "),s("h4",{attrs:{id:"如何实现一个通用的排序算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现一个通用的排序算法"}},[t._v("#")]),t._v(" 如何实现一个通用的排序算法")]),t._v(" "),s("p",[t._v("O(n)时间复杂度的线性排序使用场景严格，因此不适用于做通用算法，O(n^2)时间复杂度的算法适用于小规模数据的排序。作为一个通用算法，选择O(nlogn)时间复杂度的算法\n实现，在此基础上再结合数据规模做些优化，O(nlogn)时间复杂度的算法有归并、快排、堆排，但归并不是原地排序算法，空间复杂度高，不适合。因此一般采用归并排序作为\n通用实现算法，归并是基于递归实现的，因此有栈溢出等风险，因此可以基于堆实现方法调用栈。脱离系统内置的栈限制。另外对于小规模数据的排序，O(n^2)时间复杂度的算法\n实际占用时间可能小于O(nlogn)的，因此在小规模数据场景下，算法可以退化为使用O(nlogn)的插入排序算法。")]),t._v(" "),s("h3",{attrs:{id:"生活中的数据结构与算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生活中的数据结构与算法"}},[t._v("#")]),t._v(" 生活中的数据结构与算法")]),t._v(" "),s("h4",{attrs:{id:"图书馆的书籍存放方式-借一本书查找其位置的算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图书馆的书籍存放方式-借一本书查找其位置的算法"}},[t._v("#")]),t._v(" 图书馆的书籍存放方式，借一本书查找其位置的算法")]),t._v(" "),s("h2",{attrs:{id:"do-it"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#do-it"}},[t._v("#")]),t._v(" do it")]),t._v(" "),s("h3",{attrs:{id:"链表-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表-2"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),s("ul",[s("li",[t._v("单链表反转")]),t._v(" "),s("li",[t._v("链表中环的检测")]),t._v(" "),s("li",[t._v("两个有序的链表合并")]),t._v(" "),s("li",[t._v("删除链表倒数第n个结点")]),t._v(" "),s("li",[t._v("求链表的中间结点")])])])}),[],!1,null,null,null);a.default=v.exports}}]);