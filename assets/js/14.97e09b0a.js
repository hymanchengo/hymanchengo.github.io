(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{501:function(t,a,s){t.exports=s.p+"assets/img/collections.e3500cb9.png"},502:function(t,a,s){t.exports=s.p+"assets/img/map.5af7e306.png"},518:function(t,a,s){"use strict";s.r(a);var r=s(4),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"java-collections-framework"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-collections-framework"}},[t._v("#")]),t._v(" Java collections framework")]),t._v(" "),r("h2",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),r("h3",{attrs:{id:"集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[t._v("#")]),t._v(" 集合")]),t._v(" "),r("p",[t._v("集合是表示一组对象的对象，有时称为容器。用于将一组元素放到单一单元中。用于CRUD内存数据。集合的概念我们并不陌生，\n如火柴盒里的火柴就构成了这么一个集合，类似的还有一副扑克。")]),t._v(" "),r("h3",{attrs:{id:"集合框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集合框架"}},[t._v("#")]),t._v(" 集合框架")]),t._v(" "),r("p",[t._v("集合框架是表示和操作各类集合的统一体系结构，独立于集合的实现细节。\n它包含")]),t._v(" "),r("ul",[r("li",[t._v("接口\n表示集合的抽象数据类型，接口使得我们可以独立于具体的集合实现来操作集合。面向对象语言中，接口通常形成层次结构")]),t._v(" "),r("li",[t._v("实现\n集合接口的具体实现。本质上是可重用的数据结构")]),t._v(" "),r("li",[t._v("算法\n对实现集合的对象执行有用计算的方法，这些方法可以说成多态的，因为它可以作用在不同的集合实现上。本质上算法是可重用的功能\n接口，实现，汇总操作，算法构成了java集合框架")])]),t._v(" "),r("p",[t._v("集合框架提供了一套统一的接口完成不同场景下的数据计算，我们可以根据不同场景，选用合适的集合实现，调用集合框架提供的计算方法(算法)，完成对数据的处理需求")]),t._v(" "),r("h3",{attrs:{id:"集合框架的优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集合框架的优点"}},[t._v("#")]),t._v(" 集合框架的优点")]),t._v(" "),r("p",[t._v("如下的API可以理解为一个函数")]),t._v(" "),r("ul",[r("li",[t._v("降低使用门槛，你不需要自己编写数据结构和算法。也不需要写适配器对象或者转换代码来使不相关的API实现互操作性。集合框架都为你实现了。")]),t._v(" "),r("li",[t._v("提升程序速度和质量，集合框架提供高性能的数据结构和算法。每个接口的不同实现可以切换。更多的时间被用于提示程序的质量和性能")]),t._v(" "),r("li",[t._v("不同API之间可以通过传递集合参数来实现互操作性。")]),t._v(" "),r("li",[t._v("降低学习和使用新API所花费的努力。以往API之间传递集合会用子API来操作对应集合。现在集合统一了，无需这些API。")]),t._v(" "),r("li",[t._v("和上面优势类似，创建依赖集合的API时不需要重新造轮子，直接使用标准集合接口")]),t._v(" "),r("li",[t._v("促进软件重用。遵循标准集合接口的新的数据结构和操作实现标准接口对象的新的算法同样可用于已有代码。")])]),t._v(" "),r("h2",{attrs:{id:"集合框架图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集合框架图"}},[t._v("#")]),t._v(" 集合框架图")]),t._v(" "),r("p",[t._v("分为2类")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("按单个元素存储的Collection\n"),r("img",{attrs:{src:s(501),alt:"By Ramlmn - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=64043967"}}),t._v(" "),r("center",{staticStyle:{"font-size":"14px",color:"#C0C0C0","text-decoration":"underline"}},[t._v("By Ramlmn - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=64043967")])],1)]),t._v(" "),r("li",[r("p",[t._v("按Key-Value存储的Map\n"),r("img",{attrs:{src:s(502),alt:"map"}}),t._v(" "),r("center",{staticStyle:{"font-size":"14px",color:"#C0C0C0","text-decoration":"underline"}},[t._v("By ramlmn - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=64044187")])],1)])]),t._v(" "),r("h2",{attrs:{id:"list集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#list集合"}},[t._v("#")]),t._v(" List集合")]),t._v(" "),r("p",[t._v("线性数据结构，遍历结果是稳定的，常用实现为ArrayList和LinkedList")]),t._v(" "),r("h3",{attrs:{id:"使用集合最佳实践"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用集合最佳实践"}},[t._v("#")]),t._v(" 使用集合最佳实践")]),t._v(" "),r("p",[t._v("如果实现知道集合要存储的元素个数范围，那么在初始化集合时，最好明确指定集合的容量，避免集合反复扩容的性能开销。")]),t._v(" "),r("p",[t._v("通用List实现")]),t._v(" "),r("h3",{attrs:{id:"arraylist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[t._v("#")]),t._v(" ArrayList")]),t._v(" "),r("h4",{attrs:{id:"特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),r("ul",[r("li",[t._v("底层数据结构\n数组，数组本质是一连串连续的内存空间。思想是存储相同类型的多个元素。数组元素个数是预先定义的。")]),t._v(" "),r("li",[t._v("动态扩容\n虽然数组是固定大小的。但是ArrayList底层实现数组动态扩容，扩容通过新增一个1.5倍容量的数组，并将原数组元素拷贝进来\n"),r("ul",[r("li",[t._v("jdk8实现"),r("div",{staticClass:"language-java extra-class"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[t._v("  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureExplicitCapacity")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" minCapacity"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      modCount"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n      "),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// overflow-conscious code")]),t._v("\n      "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("minCapacity "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" elementData"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n          "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("grow")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("minCapacity"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])])]),t._v(" "),r("li",[t._v("初始容量\n10")]),t._v(" "),r("li",[t._v("非线程安全")]),t._v(" "),r("li",[t._v("特性\n随机访问快，插入删除较慢（当需要移动数组中其他的元素时）")])]),t._v(" "),r("h4",{attrs:{id:"常用方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常用方法"}},[t._v("#")]),t._v(" 常用方法")]),t._v(" "),r("ul",[r("li",[t._v("add\nadd方法在列表的末尾添加指定元素")]),t._v(" "),r("li",[t._v("remove\n1.根据索引移除，该元素后面的元素都往左移动一个位置\n2.根据元素删除，删除第一次出现的元素")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//可分配最大的元素个数\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n//如果不指定初始分配大小，或小于初始分配大小，则默认分配10\nprivate static final int DEFAULT_CAPACITY = 10;\n\n\npublic class ArrayListExample {\n    public static void main(String[] args) {\n        List arrayList = new ArrayList<>();\n        for(int i = 0; i < 5; i++) {\n            arrayList.add(i + 1);\n        }\n\t\t//[1, 2, 3, 4, 5]\n        System.out.println(arrayList);\n\t\t// 移除元素2\n        arrayList.remove((Integer)2);\n\t\t//移除索引位置为2的元素\n        arrayList.remove(2);\n        System.out.println(arrayList);\n    }\n}\n")])])]),r("h3",{attrs:{id:"linkedlist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[t._v("#")]),t._v(" LinkedList")]),t._v(" "),r("ul",[r("li",[t._v("底层数据结构\n双向链表，存储的元素在内存空间是非连续的。元素由数据及地址部分组成，元素间使用指针和地址连接。")]),t._v(" "),r("li",[t._v("非线程安全")]),t._v(" "),r("li",[t._v("特性\n插入和删除速度快，随机方法速度慢。")]),t._v(" "),r("li",[t._v("实现AbstractList和Deque(double-ended queue readed as deck)\nDeque接口既可以用作队列，也可以用作栈。分别有2套API来操作对应形态的数据结构")]),t._v(" "),r("li",[t._v("优点\n可以关联零散的内存空间，提升内存利用率。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('public class LinkedListExample {\n    public static void main(String[] args) {\n        LinkedList linkedList = new LinkedList();\n        linkedList.add("abc");\n        linkedList.add(12);\n        linkedList.addFirst("first");\n        linkedList.addLast("last");\n        System.out.println(linkedList);\n    }\n}\n')])])]),r("p",[t._v("特殊用途List实现")]),t._v(" "),r("h3",{attrs:{id:"copyonwritearraylist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist"}},[t._v("#")]),t._v(" CopyOnWriteArrayList")]),t._v(" "),r("h4",{attrs:{id:"特性-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特性-2"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),r("ul",[r("li",[t._v("底层数据结构\ncopy-on-write数组")])]),t._v(" "),r("h2",{attrs:{id:"queue集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#queue集合"}},[t._v("#")]),t._v(" Queue集合")]),t._v(" "),r("ul",[r("li",[t._v("特性\n先进先出，特殊的线性表，在一端获取，在另一端插入。")])]),t._v(" "),r("h3",{attrs:{id:"blockingqueue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue"}},[t._v("#")]),t._v(" BlockingQueue")]),t._v(" "),r("h2",{attrs:{id:"map集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#map集合"}},[t._v("#")]),t._v(" Map集合")]),t._v(" "),r("p",[t._v("以键-值对作为存储元素实现的哈希结构\nkey是hash函数运算后得到的唯一值。")]),t._v(" "),r("h3",{attrs:{id:"hashmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[t._v("#")]),t._v(" HashMap")]),t._v(" "),r("ul",[r("li",[t._v("初始容量大小16")]),t._v(" "),r("li",[t._v("线程不安全")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('public class MapExample {\n    public static void main(String[] args) {\n        Map<String, Object> map = new HashMap();\n        map.put("a", 123);\n        map.put("b", "asda");\n\n        System.out.println(map.keySet());\n        System.out.println(map.values());\n\n        for(Map.Entry<String, Object> entry : map.entrySet()) {\n            System.out.println(entry.getKey() + ":" + entry.getValue());\n        }\n    }\n}\n')])])]),r("p",[t._v("HashMap源码学习\njdk1.7与jdk1.8实现HashMap的区别")]),t._v(" "),r("h3",{attrs:{id:"concurrenthashmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[t._v("#")]),t._v(" ConcurrentHashMap")]),t._v(" "),r("ul",[r("li",[t._v("线程安全")])]),t._v(" "),r("h3",{attrs:{id:"treemap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[t._v("#")]),t._v(" TreeMap")]),t._v(" "),r("h2",{attrs:{id:"set集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#set集合"}},[t._v("#")]),t._v(" Set集合")]),t._v(" "),r("ul",[r("li",[t._v("特性\n不允许出现重复元素")])]),t._v(" "),r("h3",{attrs:{id:"hashset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[t._v("#")]),t._v(" HashSet")]),t._v(" "),r("ul",[r("li",[t._v("底层实现\nHashMap。value值为固定静态对象")]),t._v(" "),r("li",[t._v("不能保证元素有序")])]),t._v(" "),r("h3",{attrs:{id:"treeset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[t._v("#")]),t._v(" TreeSet")]),t._v(" "),r("ul",[r("li",[t._v("底层实现\nTreeMap。树结构")]),t._v(" "),r("li",[t._v("元素插入有序")])]),t._v(" "),r("h3",{attrs:{id:"linkedhashset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashset"}},[t._v("#")]),t._v(" LinkedHashSet")]),t._v(" "),r("ul",[r("li",[t._v("继承自HashSet")]),t._v(" "),r("li",[t._v("元素插入有序")])]),t._v(" "),r("h2",{attrs:{id:"接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),r("h2",{attrs:{id:"实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),r("h2",{attrs:{id:"汇总操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#汇总操作"}},[t._v("#")]),t._v(" 汇总操作")]),t._v(" "),r("h2",{attrs:{id:"算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),r("h2",{attrs:{id:"自定义实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自定义实现"}},[t._v("#")]),t._v(" 自定义实现")]),t._v(" "),r("h2",{attrs:{id:"互用性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#互用性"}},[t._v("#")]),t._v(" 互用性")]),t._v(" "),r("h1",{attrs:{id:"数组与集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组与集合"}},[t._v("#")]),t._v(" 数组与集合")]),t._v(" "),r("h2",{attrs:{id:"数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),r("p",[t._v("数组是容器对象")]),t._v(" "),r("ul",[r("li",[t._v("特性\n大小固定。存放单一元素类型。")]),t._v(" "),r("li",[t._v("声明数组类型")])]),t._v(" "),r("div",{staticClass:"language-java extra-class"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//声明指向整型数组的变量arr，此时并不实际创建数组")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" arr\n")])])]),r("ul",[r("li",[t._v("创建数组，为数组分配内存空间")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("arr = new int[10]\n")])])]),r("ul",[r("li",[t._v("初始化数组")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("arr[0] = 1;\n")])])]),r("ul",[r("li",[t._v("访问数组")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("int a = arr[0];\n")])])]),r("ul",[r("li",[t._v("创建并初始化数组")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//此时数组大小由逗号分隔的元素的个数决定\nint[] a = {1,2};\n")])])]),r("ul",[r("li",[t._v("多维数组\njava多维数组和C不一样，多维数组低维元素本身指向数组，因此，高维的数组长度可以不一样，因此低纬实际上是个逻辑概念")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('public class ArrAndCollectionExample {\n    public static void main(String[] args) {\n\t    //数组静态初始化\n        String[] arr = {"a", "b"};\n        Object obj = arr;\n        ((String[])obj)[0] = "1";\n        System.out.println(arr[0]);\n        System.out.println(Arrays.asList(arr));\n\t\t//动态初始化\n        String[] arr2 = new String[2];\n        arr2[0] = "1";\n        arr2[1] = "2";\n        System.out.println(Arrays.asList(arr2));\n//        String[] errArr = new String[-1]; runtime error NegativeArraySizeException\n\n        //二维数组\n        int[][] multipleArr = new int[2][];\n        multipleArr[0] = new int[]{1, 2, 3};\n        multipleArr[1] = new int[] {1};\n        int total = 0;\n        for(int i = 0; i< multipleArr.length; i++) {\n            for (int j = 0; j < multipleArr[i].length; j++) {\n                total++;\n                System.out.println(multipleArr[i][j]);\n            }\n        }\n        System.out.println("共" + total + "个元素");\n\n    }\n}\n\n')])])]),r("ul",[r("li",[t._v("拷贝数组\nSystem类提供了一个拷贝数组的方法")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('String[] sourceString ={"h", "e", "l", "l"};\nString[] destString = new String[2];\nSystem.arraycopy(sourceString, 1, destString, 0, 2);\n//[e,l]\nSystem.out.println(Arrays.asList(destString));\n')])])]),r("ul",[r("li",[t._v("数组操作\nArrays工具类提供对数组复制，数组排序，数组搜索的有用方法")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("char[] hello = {'h', 'e', 'l', 'l', 'o'};\n//范围 [0,5)\nchar[] helloCopy = Arrays.copyOfRange(hello, 0, 3);\n//返回hel\nSystem.out.println(String.valueOf(helloCopy));\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//对数组进行二分查找，注意数组必须是有序的。否则结果是不确定的\nint index = Arrays.binarySearch(new int[] {1, 3, 5, 7, 9}, 7);\nSystem.out.println(index);\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//比较数组是否相等\nboolean eq = Arrays.equals(new int[]{1, 2}, new int[]{1,2});\n//true\nSystem.out.println(eq);\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('//数组排序\nint[] notOrderedArr = {1, 10, 5, 80, 40};\nArrays.parallelSort(notOrderedArr);\nfor(int i : notOrderedArr) {\n    System.out.print(i + " ");\n}\n')])])]),r("ul",[r("li",[t._v("数组遍历")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('for(int i : notOrderedArr) {\n    System.out.print(i + " ");\n}\n\n//length属性\nfor(int i = 0; i < notOrderedArr.length; i++) {\n    //字符串的length方法\n\tSystem.out.println("1212".length());\n}\n\n//注意这边不能写成int[] 因为Arrays.asList接收的数组是对象数组\nInteger[] intArr = {1, 2, 3};\n//输出123\nArrays.asList(intArr).stream().forEach(x-> System.out.print(x));\n')])])]),r("h2",{attrs:{id:"arraylist-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-2"}},[t._v("#")]),t._v(" ArrayList")]),t._v(" "),r("p",[t._v("Array可认为是逻辑上的动态大小的数组")]),t._v(" "),r("h2",{attrs:{id:"数组和集合间的相互转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组和集合间的相互转换"}},[t._v("#")]),t._v(" 数组和集合间的相互转换")]),t._v(" "),r("p",[t._v("数组和集合都是存储元素的容器。他们之间可以进行转换。")]),t._v(" "),r("ul",[r("li",[t._v("数组转换为集合 Arrays.asList\n使用Arrays.asList转换后的list结构是不能变更的（即不能添加和删除）。Arrays.asList仅仅将数组包装，让他看起来像个list")])]),t._v(" "),r("p",[t._v("如下将数组转换为List后，可以操作List修改原数组的值，但是不能使用我们常使用的ArrayList的add,remove方法。一旦使用就会扔出UnsupportedOperationException。\n通过源码可以看出asList返回的ArrayList类是Arrays工具类的内部静态类，它同样继承了AbstractList。遗憾的是它并没有重写AbstractList中的add和remove方法。\n而AbstractList的add和remove实现默认扔出UnsupportedOperationException实现。除非子类对其进行复写。")]),t._v(" "),r("p",[t._v("Arrays.asList体现的是适配器模式，可以像List那样通过get和set获取和修改元素。\n问题来了，为什么内部静态类ArrayList不实现add和remove方法呢。我认为这是设计初衷。这种设计只提供原数组的视图。数组本身具有固定大小。因此便不提供add和remove方法。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("public class Arrays {\n// ...\nprivate static class ArrayList<E> extends AbstractList<E>\n        implements RandomAccess, java.io.Serializable {\n}\n// ...\n}\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('String[] helloWorld = {"Hello", "World"};\n//数组转换为list\nList<String> strList =  Arrays.asList(helloWorld);\nstrList.set(1, "hxchen");\n//hxchen\nSystem.out.println(helloWorld[1]);\n//Exception in thread "main" java.lang.UnsupportedOperationException\nstrList.add("java");\n')])])])])}),[],!1,null,null,null);a.default=e.exports}}]);