(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{547:function(a,t,e){"use strict";e.r(t);var v=e(4),l=Object(v.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"常用三方库api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用三方库api"}},[a._v("#")]),a._v(" 常用三方库API")]),a._v(" "),e("h3",{attrs:{id:"jackson"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jackson"}},[a._v("#")]),a._v(" Jackson")]),a._v(" "),e("ul",[e("li",[e("p",[e("code",[a._v("com.fasterxml.jackson.annotation.JsonIgnoreProperties")]),a._v("注解"),e("br"),a._v("\n指定序列化、反序列化过程中要忽略的属性。字段：leave me alone.")]),a._v(" "),e("ul",[e("li",[a._v("value数组指定要忽略的属性")]),a._v(" "),e("li",[a._v("ignoreUnknown指定反序列化时是否要忽略不能识别的属性（没有setter或creator的属性）。不影响序列化过程")]),a._v(" "),e("li",[a._v("allowGetters对于只读属性，允许它的setters,在value数组中忽略了其序列化及反序列化，但该属性可以微调，对于只读属性可以序列化，而不能反序列化。")]),a._v(" "),e("li",[a._v("allowSetters对于只写属性，允许反序列化，不允许序列化")])])]),a._v(" "),e("li",[e("p",[e("code",[a._v("com.fasterxml.jackson.annotation.JsonFormat")]),a._v("注解\n用来配置属性值被序列化细节的通用注解。和其他注解不一样，它并没有一个全局的解释，效果取决于被注解的属性的数据类型（更具体来说取决于使用的序列化器和反序列化器）\n常用的如日期序列化为数值（java时间戳）或ISO-8601兼容的时间值的字符串表示，包括pattern属性配置精确细节。\njackson 2.6起，特殊处理包括")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("java.util.Date")]),a._v(" "),e("ul",[e("li",[a._v("模型(shape)可以是字符串或数值，模式(pattern)可以包含与"),e("code",[a._v("java.text.SimpleDateFormat")]),a._v("兼容的模式定义")]),a._v(" "),e("li",[a._v("用在类（类型）上，可以通过属性注解来进行覆盖类注解行为")])])]),a._v(" "),e("li",[e("code",[a._v("java.lang.Enum")]),a._v(" "),e("ul",[e("li",[a._v("模型可以是字符串和数值，在数值（枚举索引）和文本（枚举名或toString）间互换。")]),a._v(" "),e("li",[a._v("也可以使用Object模型来序列化（反序列化不可以）java.lang.Enum为JSON对象（视这些枚举为POJO）,注意只适用于类注解，在属性上不管用。")])])]),a._v(" "),e("li",[e("code",[a._v("java.util.Collection")]),a._v(" "),e("ul",[e("li",[a._v("如果使用了Object模型，那么可以被序列化为（或从..反序列化）JSON对象。只适用于类注解，不适用于属性。")])])]),a._v(" "),e("li",[e("code",[a._v("java.lang.Number")]),a._v(" "),e("ul",[e("li",[a._v("如果使用Object模型，java.lang.Number子类可以被序列化为完整的对象，否则它们被默认序列化为一个标量值。注意：只能用在类注解上，不能使用在属性上。")])])])])]),a._v(" "),e("li",[e("p",[e("code",[a._v("java.text.SimpleDateFormat")])]),a._v(" "),e("ul",[e("li",[a._v("常见时间格式表示的正确理解")]),a._v(" "),e("li",[a._v("线程安全问题")])])]),a._v(" "),e("li",[e("p",[e("code",[a._v("com.fasterxml.jackson.annotation.JsonProperty")])]),a._v(" "),e("ul",[e("li",[a._v("标记注解，用来定义逻辑属性的非静态getter或setter或（序列化，反序列化时）是用作逻辑属性的非静态对象字段。")]),a._v(" "),e("li",[a._v('默认值("")表示字段名用作属性名')]),a._v(" "),e("li",[a._v("非空值用来指定一个不同的名字，代表JSON对象中的字段名，用来指代外部的名称")]),a._v(" "),e("li",[a._v("2.6起支持枚举")])])])])])}),[],!1,null,null,null);t.default=l.exports}}]);