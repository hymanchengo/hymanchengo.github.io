(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{548:function(t,a,v){"use strict";v.r(a);var e=v(4),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",[t._v("this is a test")])]),t._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#java-基础"}},[t._v("Java 基础")]),v("ul",[v("li",[v("a",{attrs:{href:"#肌肉记忆"}},[t._v("肌肉记忆")])]),v("li",[v("a",{attrs:{href:"#数据类型"}},[t._v("数据类型")])])])]),v("li",[v("a",{attrs:{href:"#java引用对象的类型及可达性"}},[t._v("java引用对象的类型及可达性")]),v("ul",[v("li",[v("a",{attrs:{href:"#包java-lang-ref"}},[t._v("包java.lang.ref")])]),v("li",[v("a",{attrs:{href:"#通知"}},[t._v("通知")])]),v("li",[v("a",{attrs:{href:"#自动清除的引用"}},[t._v("自动清除的引用")])]),v("li",[v("a",{attrs:{href:"#可达性"}},[t._v("可达性")])])])])])]),v("p"),t._v(" "),v("blockquote",[v("p",[t._v("This is official blog theme.")])]),t._v(" "),v("h2",{attrs:{id:"java-基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java-基础"}},[t._v("#")]),t._v(" Java 基础")]),t._v(" "),v("h3",{attrs:{id:"肌肉记忆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#肌肉记忆"}},[t._v("#")]),t._v(" 肌肉记忆")]),t._v(" "),v("p",[t._v("8 * 9 = ((8+8) + 8) +... =72！我们几乎能脱口而出，因为我们硬是记住了，不需要再进行复杂的演算。\n同样，关于2进制的幂次，我们同样需要形成肌肉式的记忆。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th"),t._v(" "),v("th"),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("2^0 = 1")]),t._v(" "),v("td",[t._v("2^1 = 2")]),t._v(" "),v("td",[t._v("2^2 = 4")]),t._v(" "),v("td",[t._v("2^3 = 8")])]),t._v(" "),v("tr",[v("td",[t._v("2^4 = 16")]),t._v(" "),v("td",[t._v("2^5 = 32")]),t._v(" "),v("td",[t._v("2^6 = 64")]),t._v(" "),v("td",[t._v("2^7 = 128")])]),t._v(" "),v("tr",[v("td",[t._v("2^8 = 256 (1 Byte)")]),t._v(" "),v("td",[t._v("2^9 = 512")]),t._v(" "),v("td",[t._v("2^10 = 1024")]),t._v(" "),v("td",[t._v("2^11 = 2048")])]),t._v(" "),v("tr",[v("td",[t._v("2^12 = 4,096")]),t._v(" "),v("td",[t._v("2^13 = 8,192‬")]),t._v(" "),v("td",[t._v("2^14 = 16,384‬")]),t._v(" "),v("td",[t._v("2^15 = 32,768‬")])]),t._v(" "),v("tr",[v("td",[t._v("2^16 = 65,536‬ (2 Byte)")]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td")])])]),t._v(" "),v("p",[t._v("另外 2^ 32 ~= 43亿（4,294,967,296‬） 占4个字节")]),t._v(" "),v("h3",{attrs:{id:"数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),v("p",[t._v("大多数编程语言都有常用数据的类型定义系统。Java是强类型的语言，在变量声明时需要指定数据类型。\nJava内置的基本数据类型我简单分为3类：\n"),v("table",[v("tr",[v("td",[t._v("简单分类"),v("br")]),v("td",[t._v("具体类型")]),t._v(" "),v("td",[t._v("表示范围")]),t._v(" "),v("td",[t._v("字节数")])]),t._v(" "),v("tr",[v("td",{attrs:{rowspan:"1"}},[t._v(" 布尔类 ")]),t._v(" "),v("td",[t._v(" boolean ")]),t._v(" "),v("td",[t._v(" true或false ")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",{attrs:{rowspan:"1"}},[t._v(" 字符类 ")]),t._v(" "),v("td",[t._v(" char ")]),t._v(" "),v("td",[t._v(" 0 ~ 65535 (以int表示)")]),t._v(" "),v("td",[t._v(" 2 ")])]),t._v(" "),v("tr",[v("td",{attrs:{rowspan:"7"}},[t._v(" 数值类 ")])]),t._v(" "),v("tr",[v("td",[t._v(" byte ")]),t._v(" "),v("td",[t._v("-128 ~ 127 ")]),t._v(" "),v("td",[t._v(" 1 ")])]),t._v(" "),v("tr",[v("td",[t._v(" short ")]),t._v(" "),v("td",[t._v(" -32768 ~ 32767 ")]),t._v(" "),v("td",[t._v(" 2 ")])]),t._v(" "),v("tr",[v("td",[t._v(" int ")]),t._v(" "),v("td",[t._v("-2147483648 ~ 2147483647")]),t._v(" "),v("td",[t._v(" 4 ")])]),t._v(" "),v("tr",[v("td",[t._v(" long ")]),t._v(" "),v("td",[t._v("-9223372036854775808 ~ 9223372036854775807")]),t._v(" "),v("td",[t._v(" 8 ")])]),t._v(" "),v("tr",[v("td",[t._v(" float ")]),t._v(" "),v("td",[t._v(" 1.4E-45 ~ 3.4028235E38")]),t._v(" "),v("td",[t._v(" 4 ")])]),t._v(" "),v("tr",[v("td",[t._v(" double ")]),t._v(" "),v("td",[t._v("4.9E-324 ~ 1.7976931348623157E308")]),t._v(" "),v("td",[t._v(" 8 ")])])]),t._v("\n可能你已注意到，boolean类型没有说明其字节数，boolean只有true和false这\n2种状态，原则上1位就够了。我们再来看看JVM规范中提到的对boolean类型的支持。")]),t._v(" "),v("p",[t._v("引用自The Java® Virtual Machine Specification Java SE 8 Edition")]),t._v(" "),v("blockquote",[v("p",[t._v("2.3.4 The boolean Type")]),t._v(" "),v("blockquote",[v("p",[t._v("Although the Java Virtual Machine defines a boolean type, it only provides\nvery limited support for it. There are no Java Virtual Machine instructions solely\ndedicated to operations on boolean values. Instead, expressions in the Java\nprogramming language that operate on boolean values are compiled to use values\nof the Java Virtual Machine int data type.\nThe Java Virtual Machine does directly support boolean arrays. Its newarray\ninstruction (§newarray) enables creation of boolean arrays. Arrays of type\nboolean are accessed and modified using the byte array instructions baload and\nbastore (§baload, §bastore).\nIn Oracle’s Java Virtual Machine implementation, boolean arrays in the Java\nprogramming language are encoded as Java Virtual Machine byte arrays, using 8 bits per\nboolean element")])])]),t._v(" "),v("h2",{attrs:{id:"java引用对象的类型及可达性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java引用对象的类型及可达性"}},[t._v("#")]),t._v(" java引用对象的类型及可达性")]),t._v(" "),v("h3",{attrs:{id:"包java-lang-ref"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#包java-lang-ref"}},[t._v("#")]),t._v(" 包java.lang.ref")]),t._v(" "),v("p",[t._v("包java.lang.ref提供引用对象类以与gc进行受限的交互。\n只由这些引用类对象指向的目标对象是可以被gc在适当的时机回收的\n包java.lang.ref提供了3种引用对象类，由强到弱分别是")]),t._v(" "),v("ul",[v("li",[t._v("软引用SoftReference\n软引用对象在gc响应内存需求时被清除。可实现对内存敏感的缓存")]),t._v(" "),v("li",[t._v("弱引用WeakReference\n弱引用对象不会阻止指向的对象的可析构，析构及回收。实现规范化映射(canonicalizing mappings)，不会阻止键值被回收")]),t._v(" "),v("li",[t._v("幻影用PhantomReference\n当gc确定幻影用指向的对象要被回收后，幻影用对象将入队列。用于比java终结机制更灵活的方式调度事前清理操作。")])]),t._v(" "),v("p",[t._v("这些引用对象类实现了抽象基类Reference类，Reference类持有目标对象的引用（由gc特别处理）及ReferenceQueue。提供get以获取目标对象，\n还提供clear清除对目标对象的引用。")]),t._v(" "),v("h3",{attrs:{id:"通知"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通知"}},[t._v("#")]),t._v(" 通知")]),t._v(" "),v("p",[t._v("在引用对象创建时，可以通过将引用对象注册到引用队列中，以在目标对象的可达性发生变更时通知程序。\n当gc确定被指向对象的可达性变更成改引用类型时，gc将引用添加到合适的队列中.此时可认为引用入队列了.\n程序可以通过轮询或阻塞队列来对队列中的引用元素进行移除.")]),t._v(" "),v("p",[t._v("注册的引用对象和它的队列是单方面关系.队列不追踪引用对象本身的状态.如果注册的引用对象本身不可达,它就不会入到\n队列中.是程序的职责来确保引用对象的可达,只要程序依然关注被指向对象.")]),t._v(" "),v("h3",{attrs:{id:"自动清除的引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自动清除的引用"}},[t._v("#")]),t._v(" 自动清除的引用")]),t._v(" "),v("h3",{attrs:{id:"可达性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可达性"}},[t._v("#")]),t._v(" 可达性")]),t._v(" "),v("p",[t._v("从强到弱,不同可达性级别反映了对象的生命周期:")]),t._v(" "),v("ul",[v("li",[t._v("当无需遍历任何引用对象就可被某些线程触达的对象是强可达的.新创建的对象是对于创建它的线程是强可达的.")]),t._v(" "),v("li",[t._v("如果对象不是强可达,但是通过遍历软引用访问.则对象是软可达的.")]),t._v(" "),v("li",[t._v("如果对象不是强可达,也不是软可达,通过遍历弱引用访问,则对象是弱可达的.当弱可达对象的弱引用对象被清除了.\n对象就能被终结了.")]),t._v(" "),v("li",[t._v("如果对象不是强可达、软可达、弱可达，对象就是幻可达的。它被终结，某个幻引用指向它。")]),t._v(" "),v("li",[t._v("当对象不能被上述所有可达性触达时，对象也就是不可达的，可以被回收。")])]),t._v(" "),v("p",[t._v("Set"),v("String",[t._v(" strSet =\nll.stream().map(l-> { l.setC(l.getA()+ l.getB()); return l;})\n.collect(Collectors.collectingAndThen(\nCollectors.groupingBy(Gaga::getC, Collectors.counting()), m->{\nm.values().removeIf(l -> l == 1);\n//return m.keySet();\nreturn m.keySet();\n}));")])],1)])}),[],!1,null,null,null);a.default=_.exports}}]);